<!doctype html>
<html lang="en">

<head>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MegaFuture — World Sandbox</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
    }

    #c {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #hint {
      position: fixed;
      left: 12px;
      top: 12px;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #c9c9d2;
      background: rgba(0, 0, 0, .35);
      padding: 8px 10px;
      border-radius: 10px;
      user-select: none;
      pointer-events: none;
      white-space: pre;
    }

    #devConsole {
      position: fixed;
      left: 12px;
      bottom: 12px;
      width: min(520px, calc(100vw - 24px));
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0, 0, 0, .55);
      backdrop-filter: blur(6px);
      color: #d8d8e0;
      font: 13px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      border: 1px solid rgba(255, 255, 255, .10);
      display: none;
      /* hidden by default */
      pointer-events: none;
      /* so it never steals mouse */
      user-select: none;
      white-space: pre;
    }

    #devConsole .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #devConsole .prompt {
      opacity: .7;
    }

    #devConsole .input {
      flex: 1;
    }

    #devConsole .help {
      margin-top: 6px;
      opacity: .55;
      font-size: 12px;
    }

    :root {
      --mega-pink: #E60C9A;
    }

    #mfModal {
      position: fixed;
      inset: 0;
      z-index: 99999;
      display: grid;
      place-items: center;

      /* 50% translucent overlay */
      background: rgba(0, 0, 0, .5);

      overflow: hidden;
      user-select: none;
    }

    #mfModal .stage {
      width: min(92vw, 900px);
      aspect-ratio: 16 / 9;
      display: grid;
      place-items: center;
      perspective: 1200px;
      position: relative;
    }

    #mfModal .space {
      position: relative;
      width: min(90vw, 760px);
      aspect-ratio: 16 / 9;
      transform-style: preserve-3d;
    }

    #mfModal .logoWrap {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
    }

    #mfModal .stack {
      position: absolute;
      inset: 0;
      transform-style: preserve-3d;
    }

    #mfModal .layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;

      animation-name: microDrift;
      animation-timing-function: ease-in-out;
      animation-iteration-count: infinite;
      will-change: transform;
    }

    /* lock logo_1 only */
    #mfModal .layer.noDrift {
      animation: none !important;
      transform: none !important;
      will-change: auto;
    }

    @keyframes microDrift {
      0% {
        transform: translate3d(0px, 0px, 0);
      }

      50% {
        transform: translate3d(var(--dx, 0px), var(--dy, 0px), 0);
      }

      100% {
        transform: translate3d(0px, 0px, 0);
      }
    }

    #mfModal .carousel {
      position: absolute;
      left: 50%;
      top: 50%;
      transform-style: preserve-3d;
    }

    #mfModal .carousel.ring1 {
      top: 44%;
    }

    #mfModal .carousel.ring2 {
      top: 56%;
    }

    #mfModal .item {
      position: absolute;
      left: 50%;
      top: 50%;
      transform-style: preserve-3d;

      font-family:
        "Eurostile",
        "Microgramma",
        "Orbitron",
        "Bank Gothic",
        system-ui,
        sans-serif;

      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.06em;

      user-select: none;
      pointer-events: none;
      white-space: pre;

      display: inline-block;
    }

    #mfModal .ring1 .item {
      color: var(--mega-pink);
      text-shadow:
        0 0 2px rgba(230, 12, 154, .95),
        0 0 6px rgba(230, 12, 154, .75),
        0 0 12px rgba(230, 12, 154, .55),
        0 0 24px rgba(230, 12, 154, .35),
        0 0 48px rgba(230, 12, 154, .18);
    }

    #mfModal .ring1 .item::before {
      content: attr(data-ch);
      position: absolute;
      inset: 0;
      transform: scale(0.88);
      transform-origin: center;
      color: rgba(0, 0, 0, .92);
      filter: blur(0.2px);
      text-shadow: none;
      pointer-events: none;
    }

    #mfModal .ring1 .item::after {
      content: attr(data-ch);
      position: absolute;
      inset: 0;
      transform: scale(0.93);
      transform-origin: center;
      color: rgba(0, 0, 0, .55);
      filter: blur(0.6px);
      text-shadow: none;
      pointer-events: none;
    }

    #mfModal .ring2 .item {
      color: #ffffff;
      text-shadow:
        0 0 2px rgba(255, 255, 255, .95),
        0 0 6px rgba(255, 255, 255, .75),
        0 0 12px rgba(255, 255, 255, .55),
        0 0 24px rgba(255, 255, 255, .35),
        0 0 48px rgba(255, 255, 255, .18);
    }

    #mfModal #loader {
      position: absolute;
      left: 50%;
      top: 80%;
      transform: translateX(-50%);
      font-family: "Orbitron", system-ui, sans-serif;
      font-weight: 500;
      font-size: 13px;
      letter-spacing: 0.18em;
      color: rgba(255, 255, 255, .9);
      user-select: none;
      pointer-events: auto;
      text-shadow:
        0 0 6px rgba(255, 255, 255, .18),
        0 0 18px rgba(255, 255, 255, .10);
    }

    #mfModal #fictionBlurb {
      position: absolute;
      left: 50%;
      bottom: 3vh;
      transform: translateX(-50%);
      max-width: min(90vw, 720px);

      font-family: system-ui, sans-serif;
      font-size: 11px;
      line-height: 1.45;
      text-align: center;
      color: rgba(255, 255, 255, .45);

      user-select: none;
      pointer-events: none;
    }

    #mfDeath {
      position: fixed;
      inset: 0;
      z-index: 200000;
      display: none;
      place-items: center;
      background: rgba(0, 0, 0, .66);
      backdrop-filter: blur(6px);
      user-select: none;
    }

    #mfDeath .panel {
      width: min(92vw, 860px);
      padding: 18px 18px 16px;
      border-radius: 16px;
      background: rgba(0, 0, 0, .72);
      border: 1px solid rgba(255, 255, 255, .10);
      box-shadow: 0 12px 38px rgba(0, 0, 0, .55);
    }

    #mfDeath .title {
      font-family: "Orbitron", system-ui, sans-serif;
      font-weight: 700;
      letter-spacing: .12em;
      font-size: 14px;
      color: rgba(255, 255, 255, .75);
      margin-bottom: 10px;
    }

    #mfDeath .poem {
      font-family: system-ui, sans-serif;
      font-size: 13px;
      line-height: 1.55;
      color: rgba(255, 255, 255, .70);
      white-space: pre-wrap;
    }

    #mfDeath .hint {
      margin-top: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      opacity: .7;
      color: white;
    }
  </style>

  <script type="importmap">
{
  "imports": {
    "three": "./vendor/three.module.js"
  }
}
</script>
  <script>
    (() => {
      // Holds blobs + object URLs so they stay in memory
      const mem = new Map(); // url -> { blob, objectUrl, bytes }

      async function fetchToMemory(url, { signal } = {}) {
        if (mem.has(url)) return mem.get(url);

        const res = await fetch(url, { cache: "force-cache", signal });
        if (!res.ok) throw new Error(`fetch failed ${res.status} for ${url}`);
        const blob = await res.blob();
        const objectUrl = URL.createObjectURL(blob);

        const entry = { blob, objectUrl, bytes: blob.size };
        mem.set(url, entry);
        return entry;
      }

      // Optional: decode to avoid first-paint jank later
      async function decodeImageObjectUrl(objectUrl) {
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        img.src = objectUrl;
        // decode() is supported in modern browsers; fallback to onload
        if (img.decode) {
          await img.decode();
        } else {
          await new Promise((r, rej) => { img.onload = r; img.onerror = rej; });
        }
        return true;
      }

      // Concurrency-limited prefetch
      async function prewarmImages(urls, { concurrency = 2, onProgress } = {}) {
        let done = 0;
        const queue = urls.slice();

        async function worker() {
          while (queue.length) {
            const url = queue.shift();
            const entry = await fetchToMemory(url);
            await decodeImageObjectUrl(entry.objectUrl);
            done++;
            onProgress?.(done, urls.length, url, entry.bytes);
          }
        }

        const workers = Array.from({ length: Math.max(1, concurrency) }, worker);
        await Promise.all(workers);
        return true;
      }

      async function prewarmFiles(urls, { concurrency = 2, onProgress } = {}) {
        let done = 0;
        const queue = urls.slice();

        async function worker() {
          while (queue.length) {
            const url = queue.shift();
            const entry = await fetchToMemory(url);
            done++;
            onProgress?.(done, urls.length, url, entry.bytes);
          }
        }

        const workers = Array.from({ length: Math.max(1, concurrency) }, worker);
        await Promise.all(workers);
        return true;
      }

      // Expose tiny API
      window.__mfMemAssets = {
        has: (url) => mem.has(url),
        getObjectUrl: (url) => mem.get(url)?.objectUrl || url,
        getBlob: (url) => mem.get(url)?.blob || null,
        prewarmImages,
        prewarmFiles, // ✅ generic "fetch into memory" (great for audio)
      };
    })();
  </script>
</head>

<body>
  <!-- =========================
     OPENING CUTSCENE TEMPLATE
========================= -->
  <template id="mfCutsceneTpl">
    <div id="mfCutsceneModal" aria-hidden="false">
      <div class="stage" id="cs-stage">
        <div class="bgStack" id="cs-bgStack" aria-hidden="true">
          <div class="bgFrame" id="cs-bg1"></div>
          <div class="bgFrame" id="cs-bg2"></div>
          <div class="bgFrame" id="cs-bg3"></div>
          <div class="bgFrame" id="cs-bg4"></div>
          <div class="bgFrame" id="cs-bg5"></div>
        </div>

        <div class="charLayer" id="cs-charLayer">
          <div class="card" id="cs-amadeusCard" aria-hidden="true"></div>
          <div class="card" id="cs-aristocratCard" aria-hidden="true"></div>
        </div>

        <div class="captionBar">
          <div class="captionPanel">
            <div id="cs-captionText"></div>
          </div>
        </div>

        <!-- subtle prompt (shows during playback + end) -->
        <div class="csPrompt" id="csPrompt"></div>
      </div>
    </div>
  </template>

  <style>
    /* ===== Cutscene scoped styles ===== */
    #mfCutsceneModal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: #000;
      user-select: none;
      overflow: hidden;
      z-index: 100000;
      /* above everything */
    }

    #mfCutsceneModal .stage {
      width: min(92vw, 1100px);
      aspect-ratio: 16/9;
      position: relative;
      display: grid;
      place-items: center;
      border-radius: 18px;
      overflow: hidden;
      background: #000;
    }

    #mfCutsceneModal .bgStack {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 2800ms ease;
      transform: scale(1);
      transform-origin: center center;
      will-change: transform, opacity;
    }

    #mfCutsceneModal .bgStack.isVisible {
      opacity: 1;
    }

    #mfCutsceneModal .bgFrame {
      position: absolute;
      inset: 0;
      background-position: center center;
      background-repeat: no-repeat;
      background-size: contain;
      opacity: 0;
      transition: opacity 900ms ease;
      will-change: opacity;
    }

    #mfCutsceneModal .bgFrame.isOn {
      opacity: 1;
    }

    #mfCutsceneModal .bgFrame.fadeOut {
      opacity: 0 !important;
    }

    #mfCutsceneModal .charLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 2;
      opacity: 0;
      transition: opacity 1400ms ease;
    }

    #mfCutsceneModal .charLayer.isVisible {
      opacity: 1;
    }

    #mfCutsceneModal .captionBar {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 28%;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding: 0 18px 18px;
      box-sizing: border-box;
      background: linear-gradient(to top, rgba(0, 0, 0, .92), rgba(0, 0, 0, .10) 70%, rgba(0, 0, 0, 0));
      pointer-events: none;
      z-index: 3;
    }

    #mfCutsceneModal .captionPanel {
      width: min(92%, 900px);
      min-height: 84px;
      max-height: 160px;
      padding: 14px 16px;
      box-sizing: border-box;
      border-radius: 14px;
      background: rgba(0, 0, 0, .82);
      border: 1px solid rgba(255, 255, 255, .08);
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #mfCutsceneModal #cs-captionText {
      font-family: "Orbitron", system-ui, sans-serif;
      font-weight: 500;
      font-size: clamp(12px, 1.45vw, 16px);
      line-height: 1.45;
      letter-spacing: 0.02em;
      text-align: center;
      color: rgba(255, 255, 255, .72);
      white-space: pre-wrap;
      min-height: 1.5em;
      width: 100%;
      transition: opacity 260ms ease;
    }

    #mfCutsceneModal .card {
      position: absolute;
      top: 10%;
      display: inline-block;
      width: auto;
      height: auto;
      background: transparent;
      border: none;
      box-shadow: none;
      will-change: transform;
      transform-origin: center center;
    }

    #mfCutsceneModal #cs-amadeusCard {
      z-index: 4;
    }

    #mfCutsceneModal #cs-aristocratCard {
      z-index: 3;
    }

    #mfCutsceneModal .card img {
      display: block;
      width: auto;
      height: auto;
      max-width: min(40vw, 520px);
      max-height: min(58vh, 600px);
      object-fit: contain;
      background: transparent;
    }

    #mfCutsceneModal .csPrompt {
      position: absolute;
      left: 50%;
      top: 14px;
      transform: translateX(-50%);
      font-family: system-ui, sans-serif;
      font-size: 12px;
      letter-spacing: .08em;
      color: rgba(255, 255, 255, .40);
      user-select: none;
      pointer-events: none;
      z-index: 10;
    }
  </style>
  <script>
    (() => {
      // Public API: window.MF_Cutscene.play({ onStartGame })
      // - onStartGame: async function called AFTER cutscene finishes and user presses "start"

      const wait = (ms) => new Promise(r => setTimeout(r, ms));

      function mountTemplate() {
        const tpl = document.getElementById('mfCutsceneTpl');
        const frag = tpl.content.cloneNode(true);
        document.body.appendChild(frag);
        return document.getElementById('mfCutsceneModal');
      }

      function removeModal(modal) {
        if (modal && modal.parentNode) modal.parentNode.removeChild(modal);
      }

      async function mountImage(cardEl, url) {
        return new Promise((resolve) => {
          const img = new Image();
          img.decoding = "async";
          img.loading = "eager";
          img.src = window.__mfMemAssets?.getObjectUrl(url) || url;
          img.onload = () => { cardEl.innerHTML = ""; cardEl.appendChild(img); resolve(true); };
          img.onerror = () => resolve(false);
        });
      }

      function setBgFrame(el, url) {
        if (!el) return;
        const u = window.__mfMemAssets?.getObjectUrl(url) || url;
        el.style.backgroundImage = `url("${u}")`;
      }

      function preloadImages(urls) {
        return Promise.all(urls.map(url => new Promise((resolve) => {
          const img = new Image();
          img.decoding = "async";
          img.loading = "eager";
          img.src = window.__mfMemAssets?.getObjectUrl(url) || url;
          img.onload = () => resolve(true);
          img.onerror = () => resolve(false);
        })));
      }

      window.MF_Cutscene = {
        async play({ onStartGame } = {}) {
          // ---- FILES (same as your cutscene page) ----
          const AMADEUS_IMG = "images/amadeus.png";
          const ARISTOCRAT_IMG = "images/aristocrat.png";

          const BLOOD_BAY_1 = "images/blood_bay_1.png";
          const BLOOD_BAY_2 = "images/blood_bay_2.png";
          const BLOOD_BAY_3 = "images/blood_bay_3.png";
          const BLOOD_BAY_4 = "images/blood_bay_4.png";
          const BLOOD_BAY_5 = "images/blood_bay_5.png";

          const BG_FADE_ON_TEXT = "It is a time when the sun burns weak and red.";
          const ACTORS_FADE_ON_EXACT = "These \"men,\" as they once fashioned themselves.";

          const BG2_ON_TEXT = "You are of the two remaining immortals.";
          const BG3_ON_TEXT = "A clone.";
          const BG4_ON_TEXT = "An experiment.";
          const BG5_ON_TEXT = "A prisoner.";

          const PRISONER_WAIT_BEFORE_CLEANUP_MS = 4000;
          const PRISONER_EXTRA_WAIT_BEFORE_ACTORS_MS = 2000;
          const BG_FADE_OUT_MS = 900;

          const MOVE_MS = 24000;
          const SOLO_SLIDE_MS = 8000;

          const ZOOM_FROM = 1.00;
          const ZOOM_TO = 1.22;
          const ZOOM_EASE = "linear";

          const BG_SCALE_FROM = 1.00;
          const BG_SCALE_TO = 0.88;

          const MOVE_EASE = "cubic-bezier(0.10, 0.00, 0.90, 1.00)";
          const SOLO_EASE = "cubic-bezier(0.10, 0.00, 0.90, 1.00)";

          const DELETE_BLUE_ON_TEXT = "In their infighting, only one remained.";
          const EXTRA_HOLD_BEFORE_DELETE_MS = 5000;
          const DELAY_BEFORE_RED_RECENTER_MS = 2000;

          const storyCues = [
            { text: "It is a time when the sun burns weak and red.", ms: 4000 },
            { text: "The days are long and the seasons are cold.", ms: 5000 },
            { text: "This is The MegaFuture", ms: 3000 },
            { text: "", ms: 900 },

            { text: "You are of the two remaining immortals.", ms: 4000 },
            { text: "A clone.", ms: 2400 },
            { text: "An experiment.", ms: 2400 },
            { text: "A prisoner.", ms: 2400 },
            { text: "", ms: 900 },

            { text: "These \"men,\" as they once fashioned themselves.", ms: 4000 },
            { text: "Poisoned the Earth.", ms: 3000 },
            { text: "Hardened their bodies.", ms: 3000 },
            { text: "And created a cabal of everlasting corruption.", ms: 4000 },
            { text: "In their infighting, only one remained.", ms: 4000 },
            { text: "", ms: 2000 },

            { text: "A single authority with absolute control over Earth’s biosphere.", ms: 3400 },
            { text: "Over life.", ms: 2300 },
            { text: "Over death.", ms: 2300 },
            { text: "", ms: 1800 },

            { text: "Over you.", ms: 3400 },
            { text: "", ms: 900 },

            { text: "Your goal is to escape this madness.", ms: 3400 },
            { text: "but...", ms: 3000 },
            { text: "is it even possible?", ms: 3400 }
          ];

          // ---- mount DOM ----
          const modal = mountTemplate();

          const stage = modal.querySelector("#cs-stage");
          const captionText = modal.querySelector("#cs-captionText");
          const promptEl = modal.querySelector("#csPrompt");

          const bgStack = modal.querySelector("#cs-bgStack");
          const bg1 = modal.querySelector("#cs-bg1");
          let bg2 = modal.querySelector("#cs-bg2");
          let bg3 = modal.querySelector("#cs-bg3");
          let bg4 = modal.querySelector("#cs-bg4");
          let bg5 = modal.querySelector("#cs-bg5");

          const charLayer = modal.querySelector("#cs-charLayer");
          const amadeusCard = modal.querySelector("#cs-amadeusCard");
          let aristocratCard = modal.querySelector("#cs-aristocratCard");

          // ---- helpers ----
          function setCaptionText(str) {
            captionText.style.opacity = "0";
            const safe = (str === "") ? " " : str;
            setTimeout(() => {
              captionText.textContent = safe;
              captionText.style.opacity = "1";
            }, 170);
          }

          let bgScale = BG_SCALE_FROM;
          function setBgScale(s) {
            bgScale = s;
            bgStack.style.transform = `scale(${bgScale})`;
          }

          let amadeusX = 0;
          let amadeusScale = ZOOM_FROM;
          function applyAmadeusTransform() {
            amadeusCard.style.transform = `translate3d(${amadeusX}px, 0px, 0px) scale(${amadeusScale})`;
          }
          function setAmadeusX(x) { amadeusX = x; applyAmadeusTransform(); }
          function setAmadeusScale(s) { amadeusScale = s; applyAmadeusTransform(); }
          function setCardX(cardEl, x) { cardEl.style.transform = `translate3d(${x}px, 0px, 0px)`; }

          function computePositions() {
            const rect = stage.getBoundingClientRect();
            const aRect = amadeusCard.getBoundingClientRect();
            const cardW = aRect.width;
            const padX = Math.max(18, rect.width * 0.035);
            const leftStartX = padX;
            const rightStartX = rect.width - padX - cardW;
            const leftEndX = rightStartX;
            const rightEndX = leftStartX;
            const centerX = (rect.width - cardW) / 2;
            return { leftStartX, rightStartX, leftEndX, rightEndX, centerX };
          }

          function snapToDefaultPositions() {
            const pos = computePositions();
            amadeusCard.style.transition = "none";
            if (aristocratCard && aristocratCard.isConnected) aristocratCard.style.transition = "none";

            setAmadeusScale(ZOOM_FROM);
            setAmadeusX(pos.leftStartX);

            if (aristocratCard && aristocratCard.isConnected) setCardX(aristocratCard, pos.rightStartX);

            bgStack.style.transition = "none";
            setBgScale(BG_SCALE_FROM);

            void amadeusCard.offsetHeight;
          }

          function animateSwapOnce() {
            const pos = computePositions();
            amadeusCard.style.transition = `transform ${MOVE_MS}ms ${MOVE_EASE}`;
            if (aristocratCard && aristocratCard.isConnected) {
              aristocratCard.style.transition = `transform ${MOVE_MS}ms ${MOVE_EASE}`;
            }
            requestAnimationFrame(() => {
              setAmadeusX(pos.leftEndX);
              if (aristocratCard && aristocratCard.isConnected) setCardX(aristocratCard, pos.rightEndX);
            });
          }

          function animateRedToCenter() {
            const pos = computePositions();
            amadeusCard.style.transition = `transform ${SOLO_SLIDE_MS}ms ${SOLO_EASE}`;
            requestAnimationFrame(() => setAmadeusX(pos.centerX));
          }

          function isDeleteCueText(text) {
            if (!text) return false;
            return text === DELETE_BLUE_ON_TEXT || text.includes(DELETE_BLUE_ON_TEXT);
          }

          function calcZoomDurationAfterDelete() {
            const idx = storyCues.findIndex(c => isDeleteCueText(c.text));
            if (idx === -1) return 0;
            let sum = 0;
            for (let i = idx + 1; i < storyCues.length; i++) sum += (storyCues[i]?.ms || 0);
            return Math.max(0, sum);
          }

          function startAmadeusZoomAndBgShrinkUntilStoryEnds() {
            const zoomDuration = calcZoomDurationAfterDelete() / 2; // 2x faster
            if (zoomDuration <= 0) {
              setAmadeusScale(ZOOM_TO);
              setBgScale(BG_SCALE_TO);
              return;
            }
            amadeusCard.style.transition = `transform ${zoomDuration}ms ${ZOOM_EASE}`;
            bgStack.style.transition = `transform ${zoomDuration}ms ${ZOOM_EASE}`;
            requestAnimationFrame(() => {
              setAmadeusScale(ZOOM_TO);
              setBgScale(BG_SCALE_TO);
            });
          }

          let blueDeleted = false;
          let zoomStarted = false;
          function deleteBlueNow() {
            if (blueDeleted) return;
            blueDeleted = true;

            if (aristocratCard && aristocratCard.isConnected) aristocratCard.remove();
            aristocratCard = null;

            setTimeout(() => {
              animateRedToCenter();
              if (!zoomStarted) {
                zoomStarted = true;
                setTimeout(() => startAmadeusZoomAndBgShrinkUntilStoryEnds(), SOLO_SLIDE_MS);
              }
            }, DELAY_BEFORE_RED_RECENTER_MS);
          }

          // ---- staged start ----
          let bgShown = false;
          let actorsShown = false;
          let motionStarted = false;

          let bg2On = false, bg3On = false, bg4On = false, bg5On = false;

          let cleanupStarted = false;
          let cleanupDoneAt = 0;

          function showBackgroundIfNeeded(text) {
            if (bgShown) return;
            if (!text) return;
            if (text === BG_FADE_ON_TEXT || text.includes(BG_FADE_ON_TEXT)) {
              bgShown = true;
              bgStack.classList.add("isVisible");
            }
          }

          function startPrisonerCleanupTimeline() {
            if (cleanupStarted) return;
            cleanupStarted = true;

            const now = performance.now();
            cleanupDoneAt = now + PRISONER_WAIT_BEFORE_CLEANUP_MS + BG_FADE_OUT_MS + PRISONER_EXTRA_WAIT_BEFORE_ACTORS_MS;

            (async () => {
              await wait(PRISONER_WAIT_BEFORE_CLEANUP_MS);

              [bg2, bg3, bg4, bg5].forEach(el => el?.classList.add("fadeOut"));
              await wait(BG_FADE_OUT_MS);

              [bg2, bg3, bg4, bg5].forEach(el => el?.remove());
              bg2 = bg3 = bg4 = bg5 = null;
            })();
          }

          function progressBackgroundFramesIfNeeded(text) {
            if (!text) return;

            if (!bg2On && (text === BG2_ON_TEXT || text.includes(BG2_ON_TEXT))) {
              bg2On = true; bg2?.classList.add("isOn"); return;
            }
            if (!bg3On && (text === BG3_ON_TEXT || text.includes(BG3_ON_TEXT))) {
              bg3On = true; bg3?.classList.add("isOn"); return;
            }
            if (!bg4On && (text === BG4_ON_TEXT || text.includes(BG4_ON_TEXT))) {
              bg4On = true; bg4?.classList.add("isOn"); return;
            }
            if (!bg5On && (text === BG5_ON_TEXT || text.includes(BG5_ON_TEXT))) {
              bg5On = true; bg5?.classList.add("isOn");
              startPrisonerCleanupTimeline();
              return;
            }
          }

          function revealActorsAndStartMotion() {
            if (actorsShown) return;
            actorsShown = true;
            charLayer.classList.add("isVisible");
            if (!motionStarted) {
              motionStarted = true;
              requestAnimationFrame(() => animateSwapOnce());
            }
          }

          // ---- skip + end gates ----
          let aborted = false;
          let inPlayback = true;
          let autoStartFromSkip = false; // ✅ if true, skip->start is the same keypress

          function onAnyKeyDuringPlayback(e) {
            if (e?.cancelable) e.preventDefault();
            e?.stopPropagation?.();

            if (!inPlayback) return;
            aborted = true;                 // stop the story loop ASAP
            autoStartFromSkip = true;       // ✅ same keypress also counts as "start"
          }

          function setPrompt(text) {
            promptEl.textContent = text || "";
          }

          async function playStory() {
            for (let i = 0; i < storyCues.length; i++) {
              if (aborted) break;

              const cue = storyCues[i];

              showBackgroundIfNeeded(cue.text);
              progressBackgroundFramesIfNeeded(cue.text);

              const isTheseMen = cue.text && (cue.text === ACTORS_FADE_ON_EXACT || cue.text.includes(ACTORS_FADE_ON_EXACT));

              if (isTheseMen && cleanupStarted && !actorsShown) {
                const delay = Math.max(0, cleanupDoneAt - performance.now());
                if (delay > 0) await wait(delay);

                setCaptionText(cue.text);
                revealActorsAndStartMotion();
                await wait(cue.ms);
                continue;
              }

              setCaptionText(cue.text);

              if (isTheseMen && !cleanupStarted) {
                revealActorsAndStartMotion();
              }

              if (isDeleteCueText(cue.text)) {
                await wait(cue.ms + EXTRA_HOLD_BEFORE_DELETE_MS);
                deleteBlueNow();
                continue;
              }

              await wait(cue.ms);
            }
          }

          async function toEndGate() {
            inPlayback = false;

            setCaptionText(" ");
            setPrompt("Press any key to start");

            // If the user already skipped (key OR click), don't require a second press
            if (autoStartFromSkip) return;

            await new Promise((resolve) => {
              const done = (e) => {
                if (e?.cancelable) e.preventDefault();
                e?.stopPropagation?.();

                window.removeEventListener('keydown', onKey, true);
                modal.removeEventListener('pointerdown', onPointer, true);
                resolve();
              };

              const onKey = (e) => {
                if (e.code === 'Tab') return;
                if (e.code === 'Escape') return;
                done(e);
              };

              const onPointer = (e) => {
                // optional: ignore right click
                // if (e.button === 2) return;
                done(e);
              };

              window.addEventListener('keydown', onKey, true);
              modal.addEventListener('pointerdown', onPointer, true);
            });
          }

          // ---- init visuals ----
          bgStack.classList.remove("isVisible");
          charLayer.classList.remove("isVisible");

          setBgFrame(bg1, BLOOD_BAY_1);
          setBgFrame(bg2, BLOOD_BAY_2);
          setBgFrame(bg3, BLOOD_BAY_3);
          setBgFrame(bg4, BLOOD_BAY_4);
          setBgFrame(bg5, BLOOD_BAY_5);
          bg1.classList.add("isOn");

          await preloadImages([BLOOD_BAY_1, BLOOD_BAY_2, BLOOD_BAY_3, BLOOD_BAY_4, BLOOD_BAY_5]);

          await Promise.all([
            mountImage(amadeusCard, AMADEUS_IMG),
            mountImage(aristocratCard, ARISTOCRAT_IMG),
          ]);

          snapToDefaultPositions();
          setCaptionText(storyCues[0]?.text ?? " ");
          showBackgroundIfNeeded(storyCues[0]?.text ?? "");

          // During playback: any key OR click = SKIP (but not Tab/Escape)
          setPrompt("Press any key to skip");

          const onKeySkip = (e) => {
            if (e.code === 'Tab') return;
            if (e.code === 'Escape') return;
            onAnyKeyDuringPlayback(e);
          };

          // ✅ click/tap skips too (left/middle/right all count)
          const onPointerSkip = (e) => {
            // ignore right click if you want (optional):
            // if (e.button === 2) return;

            onAnyKeyDuringPlayback(e);
          };

          window.addEventListener('keydown', onKeySkip, true);
          modal.addEventListener('pointerdown', onPointerSkip, true);

          // Resize safety
          const onResize = () => { if (!motionStarted) snapToDefaultPositions(); };
          window.addEventListener('resize', onResize, { passive: true });

          // Run story
          await playStory();

          // Cleanup playback listeners
          window.removeEventListener('keydown', onKeySkip, true);
          modal.removeEventListener('pointerdown', onPointerSkip, true);

          // End gate (press any key to start)
          await toEndGate();

          // Remove cutscene overlay
          window.removeEventListener('resize', onResize);
          removeModal(modal);

          // Now hand back to the game (pointer lock + world reload)
          if (typeof onStartGame === 'function') await onStartGame();
        }
      };
    })();
  </script>
  <div id="hint">Click to lock • WASD move • Shift sprint • Space jump</div>
  <div id="devConsole">
    <div class="row">
      <div class="prompt">&gt;</div>
      <div class="input" id="devConsoleInput"></div>
    </div>
    <div class="help">Tab to close • Enter to run</div>
  </div>
  <div id="mfDeath" aria-hidden="true">
    <div class="panel">
      <div class="title">YOU HAVE DIED</div>
      <div class="poem" id="mfDeathPoem"></div>
      <div class="hint">Press <b>R</b> to respawn</div>
    </div>
  </div>
  <div id="mfModal" aria-hidden="false">
    <div class="stage">
      <div class="space">
        <div class="logoWrap">
          <div class="stack">
            <img class="layer" src="images/megafuture_logo_4.PNG" alt="">
            <img class="layer" src="images/megafuture_logo_3.PNG" alt="">
            <img class="layer" src="images/megafuture_logo_2.PNG" alt="">
            <img class="layer noDrift" src="images/megafuture_logo_1.PNG" alt="">
          </div>

          <div class="carousel ring1" id="ringMega"></div>
          <div class="carousel ring2" id="ring232"></div>

          <div id="loader">loading.</div>
        </div>
      </div>
    </div>
    <div id="fictionBlurb">
      <div>This work is a work of fiction.</div>
      <div>All characters and events portrayed in this game are fictional.</div>
      <div>Any resemblance to real persons, living or dead, or actual events is purely coincidental.</div>
    </div>
  </div>
  <script>
    (() => {
      // show title screen immediately
      const modal = document.getElementById("mfModal");
      if (modal) modal.style.display = "grid";

      /* ===== MICRO PARALLAX (4x faster) ===== */
      const layers = document.querySelectorAll("#mfModal .stack .layer:not(.noDrift)");
      layers.forEach((img) => {
        const dx = ((Math.random() * 3.2) - 1.6).toFixed(2);
        const dy = ((Math.random() * 3.2) - 1.6).toFixed(2);
        const dur = (1.5 + Math.random() * 1.0).toFixed(2);
        const delay = (-(Math.random() * parseFloat(dur))).toFixed(2);

        img.style.setProperty("--dx", dx + "px");
        img.style.setProperty("--dy", dy + "px");
        img.style.animationDuration = dur + "s";
        img.style.animationDelay = delay + "s";
      });

      function buildGlyphRing(el, text, radius, opts = {}) {
        const { letterSpacingPx = 6, fontSizePx = 18 } = opts;
        el.innerHTML = "";

        const glyphs = [];
        for (const ch of text) {
          const d = document.createElement("div");
          d.className = "item";
          d.style.fontSize = fontSizePx + "px";
          d.textContent = ch;
          d.setAttribute("data-ch", ch);
          el.appendChild(d);
          glyphs.push(d);
        }

        const widths = glyphs.map(g => g.getBoundingClientRect().width);
        const totalPx = widths.reduce((a, b) => a + b, 0) + letterSpacingPx * (glyphs.length - 1);

        let s = -totalPx / 2;
        for (let i = 0; i < glyphs.length; i++) {
          const w = widths[i];
          const centerS = s + w / 2;
          glyphs[i].dataset.theta0 = centerS / radius;
          s += w + letterSpacingPx;
        }

        el.radius = radius;
      }

      function updateGlyphRing(el, angleDeg) {
        const r = el.radius;
        const aRad = angleDeg * Math.PI / 180;

        el.querySelectorAll(".item").forEach(g => {
          const theta0 = parseFloat(g.dataset.theta0) || 0;
          const theta = theta0 + aRad;

          const z = Math.cos(theta) * r;
          const x = Math.sin(theta) * r;

          const scale = (z + r) / (r * 2) + 0.5;
          const opacity = Math.max(0.35, scale);

          g.style.transform =
            `translate(-50%, -50%)
         translateX(${x}px)
         translateZ(${z}px)
         rotateY(${-theta * 180 / Math.PI}deg)
         scale(${scale})`;

          g.style.opacity = opacity;
        });
      }

      /* motion (UNCHANGED) */
      const FPS = 60;
      const moveFrames = 110;
      const pauseFrames = Math.round(2 * FPS);
      const cycleFrames = moveFrames + pauseFrames;

      function angleForFrame(f) {
        const m = f % cycleFrames;
        return m < moveFrames ? (m / moveFrames) * 360 : 360;
      }

      const ringMega = document.getElementById("ringMega");
      const ring232 = document.getElementById("ring232");

      buildGlyphRing(ringMega, "MEGAFUTURE", 125, { letterSpacingPx: 9, fontSizePx: 18 });
      buildGlyphRing(ring232, "232", 110, { letterSpacingPx: 10, fontSizePx: 18 });

      const START_DELAY_MS = 2000;
      const startTime = performance.now();
      let frame = 0;
      let rafId = 0;

      function tick() {
        const elapsed = performance.now() - startTime;

        if (elapsed < START_DELAY_MS) {
          updateGlyphRing(ringMega, 0);
          updateGlyphRing(ring232, 0);
          rafId = requestAnimationFrame(tick);
          return;
        }

        frame++;
        const a = angleForFrame(frame);
        updateGlyphRing(ringMega, -a);
        updateGlyphRing(ring232, +a);
        rafId = requestAnimationFrame(tick);
      }
      tick();

      /* loading cycler */
      const loaderEl = document.getElementById("loader");
      let dots = 1;
      const loaderInterval = loaderEl ? setInterval(() => {
        dots = (dots % 3) + 1;
        loaderEl.textContent = "loading" + ".".repeat(dots);
      }, 420) : 0;

      /* =========================
         WAIT FOR WORLD TO BE READY
      ========================= */

      function setModalReadyToStart() {
        if (loaderInterval) clearInterval(loaderInterval);

        if (loaderEl) {
          loaderEl.textContent = "press any key to start";
          loaderEl.style.cursor = "default";
          loaderEl.style.opacity = "1";
        }

        let started = false;

        const cleanup = () => {
          window.removeEventListener('keydown', onKeyDown, true);
          modal.removeEventListener('pointerdown', onPointerDown, true);
          window.removeEventListener('contextmenu', blockCtxMenu, true);
        };

        const start = (e) => {
          if (started) return;
          started = true;

          if (e?.cancelable) e.preventDefault();
          e?.stopPropagation?.();

          cleanup();
          closeModal(); // remove title modal FIRST

          // ✅ start music on the same user gesture
          const music = document.getElementById('mfMusic');
          if (music && music.paused) {
            music.volume = 0.6;
            music.loop = true;
            music.play().catch(() => { });
          }

          // Run opening cutscene, then enter game
          window.MF_Cutscene.play({
            onStartGame: async () => {
              await ensureFootstepsReady();

              if (window.__mfEnablePointerLock) window.__mfEnablePointerLock();
              const c = document.getElementById('c');
              if (c && !document.pointerLockElement) c.requestPointerLock();

              if (window.__mfClearKeys) window.__mfClearKeys();
            }
          });
        };

        const onKeyDown = (e) => {
          if (e.code === 'Tab') return;
          if (e.code === 'Escape') return;
          start(e);
        };

        const onPointerDown = (e) => {
          if (e.cancelable) e.preventDefault();
          e.stopPropagation();
          start(e);
        };

        window.addEventListener('keydown', onKeyDown, true);
        modal.addEventListener('pointerdown', onPointerDown, true);

        window.addEventListener('contextmenu', blockCtxMenu, true);
      }

      /* listen for the world-ready signal */
      window.addEventListener('mf:world-ready', () => {
        setModalReadyToStart();
      }, { once: true });

      function blockCtxMenu(e) {
        if (!modal || !modal.isConnected) return;
        e.preventDefault();
        e.stopPropagation();
      }

      function closeModal() {
        if (rafId) cancelAnimationFrame(rafId);
        if (loaderInterval) clearInterval(loaderInterval);

        // ✅ remove the global blocker once modal is gone
        window.removeEventListener("contextmenu", blockCtxMenu, true);

        if (modal && modal.parentNode) modal.parentNode.removeChild(modal);
      }

    })();
  </script>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from './vendor/GLTFLoader.js';

    /* =========================
       FILES
    ========================= */
    const MAP_URL = './images/map.png';
    const MEZZA_WALK_GLB = './assets/mezza_walking.glb';
    const MEZZA_RUN_GLB = './assets/mezza_running.glb';
    const MEZZA_IDLE_GLB = './assets/mezza_idle.glb';

    /* =========================
       AUDIO (walking footsteps only)
    ========================= */
    const WALK_STEP_1_URL = "./audio/step_8.mp3";
    const WALK_STEP_2_URL = "./audio/step_9.mp3";
    const WALK_STEP_3_URL = "./audio/step_4.mp3"; // <-- your new one

    const WALK_STEP_SOUNDS = [WALK_STEP_1_URL, WALK_STEP_2_URL, WALK_STEP_3_URL];

    let audioCtx = null;
    let footGain = null;
    let footBufA = null;
    let footBufB = null;
    let footBufC = null; // ✅ new
    let footNext = 0;
    let footReady = false;

    let footTimer = 0;
    // Tweak: smaller = more frequent steps
    const FOOTSTEP_INTERVAL_S = 0.42;
    // volume tuning
    const FOOTSTEP_GAIN = 0.22;

    let footLoading = false; // add near your other foot vars

    //Controls the gradients of green for all hills.
    const brightestHillColor = '#2ED07B';

    async function ensureFootstepsReady() {
      if (footReady || footLoading) return footReady;
      footLoading = true;

      // Must be called after a user gesture (your start)
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") {
        try { await audioCtx.resume(); } catch { }
      }

      footGain = footGain || audioCtx.createGain();
      footGain.gain.value = FOOTSTEP_GAIN;
      footGain.connect(audioCtx.destination);

      async function decodeFromMemOrFetch(url) {
        const blob = window.__mfMemAssets?.getBlob(url);
        const ab = blob ? await blob.arrayBuffer() : await (await fetch(url)).arrayBuffer();
        return await audioCtx.decodeAudioData(ab);
      }

      try {
        [footBufA, footBufB, footBufC] = await Promise.all([
          decodeFromMemOrFetch(WALK_STEP_1_URL),
          decodeFromMemOrFetch(WALK_STEP_2_URL),
          decodeFromMemOrFetch(WALK_STEP_3_URL),
        ]);

        footReady = true;
        footLoading = false;
        return true;
      } catch (err) {
        console.warn("[audio] footstep decode failed:", err);
        footReady = false;
        footLoading = false;
        return false;
      }
    }

    // ✅ add this line after the function definition
    window.ensureFootstepsReady = ensureFootstepsReady;

    function playFootstep() {
      if (!footReady || !audioCtx || !footGain) return;

      // ~15% chance to use the “spice” sample
      const RARE_CHANCE = 0.35;

      let buf = null;

      if (footBufC && Math.random() < RARE_CHANCE) {
        buf = footBufC;
      } else {
        buf = (footNext++ % 2 === 0) ? footBufA : footBufB; // your existing A/B alternation
      }

      if (!buf) return;

      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      src.playbackRate.value = 0.96 + Math.random() * 0.08;

      src.connect(footGain);
      src.start();
    }

    /* =========================
       WORLD TUNING
    ========================= */
    const CELL_M = 1.0;
    const BASE_MAX_HEIGHT = 140.0;
    const HEIGHT_CURVE_POW = 0.85;

    const PLAYER_SCALE = 2.0;
    const BASE_EYE_HEIGHT = 1.7;
    const PLAYER_EYE_HEIGHT = BASE_EYE_HEIGHT * PLAYER_SCALE;

    const SPEED_WALK = 10.0;
    const SPRINT_SPEED_MODIFIER = 5;
    const SPEED_SPRINT = 16.0 * SPRINT_SPEED_MODIFIER;

    /* Air control */
    const AIR_MAX_SPEED_WALK = SPEED_WALK;
    const AIR_MAX_SPEED_SPRINT = SPEED_SPRINT;
    const AIR_ACCEL = 26.0;
    const AIR_FRICTION = 0.0;

    /* Terrain mesh density */
    const SAMPLE_STEP = 4;
    const SMOOTH_PASSES = 3;
    const TOL = 24;

    /* =========================
       HEIGHTFIELD SHAPE CONTROL (NO NEW GEOMETRY)
    ========================= */
    const TOP_FLAT_GN_THRESHOLD = 0.92; // tweak 0.88..0.96
    const SLOPE_PASSES = 16;            // 10..24

    /* =========================
       PHYSICS
    ========================= */
    const GRAVITY = 28.0;
    const JUMP_HEIGHT_MULT = 2.0;
    const JUMP_VEL = Math.sqrt(2 * GRAVITY * (3.0 * JUMP_HEIGHT_MULT));

    const COYOTE_TIME = 0.12;
    const JUMP_BUFFER = 0.12;

    const PLAYER_RADIUS = 0.38 * PLAYER_SCALE;
    const PLAYER_CAPSULE_H = 1.45 * PLAYER_SCALE;
    const DOWN_FOLLOW_SPEED = 26.0 * PLAYER_SCALE;
    const MAX_STEP_UP = 0.55 * PLAYER_SCALE;

    const SUBSTEP_DIST = 0.35 * PLAYER_SCALE;

    /* =========================
       SLOPE SPEED (GROUND ONLY)
    ========================= */
    const SLOPE_SAMPLE_DIST = 1.2 * PLAYER_SCALE;
    const SLOPE_STRENGTH_UP = 0.90;
    const SLOPE_STRENGTH_DN = 0.60;
    const SLOPE_MAX_UP_PENALTY = 0.55;
    const SLOPE_MAX_DN_BOOST = 1.30;

    /* =========================
       SEA
    ========================= */
    let SEA_LEVEL = 0.0;
    const WATER_PLANE_Y = -10000.0;
    const FLOOR_Y = -99999;

    /* Sky/water size sync */
    const SKY_RADIUS = 25000;
    const WATER_PLANE_SIZE = SKY_RADIUS * 2.0;

    /* =========================
       THIRD PERSON CAMERA
    ========================= */
    let VIEW_MODE = 'third'; // 'first' | 'third'  (default: third-person)
    let THIRD_CAM_BACK = 9.0 * PLAYER_SCALE; // <-- mutable for mousewheel zoom
    const THIRD_CAM_BACK_MIN = 2.2 * PLAYER_SCALE;
    const THIRD_CAM_BACK_MAX = 40.0 * PLAYER_SCALE;
    const THIRD_CAM_ZOOM_SPEED = 0.02 * PLAYER_SCALE;

    const THIRD_CAM_UP = 3.2 * PLAYER_SCALE;
    const THIRD_LOOK_UP = 1.35 * PLAYER_SCALE; // look-at height above ground
    const THIRD_COLLIDE_PADDING = 0.22;

    /* =========================
       MOUSE LOOK (pointer lock)
    ========================= */
    let isLocked = false;
    let yaw = -THREE.MathUtils.degToRad(30); // 30° clockwise (turn right)
    let pitch = 0;  // radians
    const MOUSE_SENS = 0.0022;
    const PITCH_MIN = THREE.MathUtils.degToRad(-80);
    const PITCH_MAX = THREE.MathUtils.degToRad(80);

    function applyCameraRotation() {
      camera.rotation.set(pitch, yaw, 0, 'YXZ');
    }

    /* =========================
       TREE PARAMS (needed by blob-literal trees)
    ========================= */
    const TREE_SCALE = 10.0;
    const TREE_TRUNK_H_BASE = 2.6 * TREE_SCALE;
    const TREE_TRUNK_R_BASE = 0.18 * TREE_SCALE;
    const TREE_TRUNK_TOP_R_BASE = 0.015 * TREE_SCALE;

    const BRANCHES_PER_TREE = 6;
    const BRANCH_MIN_L_BASE = 0.45 * TREE_SCALE;
    const BRANCH_MAX_L_BASE = 1.15 * TREE_SCALE;
    const BRANCH_R0_BASE = 0.06 * TREE_SCALE;
    const BRANCH_R1_BASE = 0.014 * TREE_SCALE;
    const BRANCH_MIN_Y = 0.35;
    const BRANCH_MAX_Y = 0.95;

    const TREE_COLOR_TRUNK = 0x000000;
    const TREE_COLOR_BRANCH = 0x000000;

    /* =========================
       COLORS (from your PNG)
    ========================= */
    const COLORS = {
      TREE: rgb('#8b5a2b'),
      HOUSE: rgb('#ff0000'),
      PLAYER: rgb('#0000ff'),
      BORDER: rgb('#ffff00')
    };

    function rgb(hex) {
      const s = hex.replace('#', '');
      return [parseInt(s.slice(0, 2), 16), parseInt(s.slice(2, 4), 16), parseInt(s.slice(4, 6), 16)];
    }
    function near(a, b) {
      return Math.abs(a[0] - b[0]) <= TOL && Math.abs(a[1] - b[1]) <= TOL && Math.abs(a[2] - b[2]) <= TOL;
    }
    function isGreenish(r, g, b) {
      return (g > r + 20) && (g > b + 20);
    }

    /* Robust "yellow = water" detection */
    function isBorder(r, g, b) {
      return near([r, g, b], COLORS.BORDER) || (r >= 230 && g >= 230 && b <= 120);
    }
    function isSpecial(r, g, b) {
      return near([r, g, b], COLORS.HOUSE) ||
        near([r, g, b], COLORS.TREE) ||
        near([r, g, b], COLORS.PLAYER);
    }
    function isTreePixel(r, g, b, a) {
      if (a < 16) return false;
      return near([r, g, b], COLORS.TREE);
    }
    function isHousePixel(r, g, b, a) {
      if (a < 16) return false;
      return near([r, g, b], COLORS.HOUSE);
    }

    /* =========================
       TOON RAMPS
    ========================= */
    function makeToonRamp5(stops) {
      const c = document.createElement('canvas');
      c.width = 256; c.height = 1;
      const ctx = c.getContext('2d');
      const n = 5;
      for (let i = 0; i < n; i++) {
        ctx.fillStyle = stops[i];
        const x0 = Math.floor((i / n) * c.width);
        const x1 = Math.floor(((i + 1) / n) * c.width);
        ctx.fillRect(x0, 0, Math.max(1, x1 - x0), 1);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.NearestFilter;
      tex.magFilter = THREE.NearestFilter;
      tex.generateMipmaps = false;
      tex.needsUpdate = true;
      return tex;
    }

    function makeToonRampWeighted(stops, weights) {
      const c = document.createElement('canvas');
      c.width = 256; c.height = 1;
      const ctx = c.getContext('2d');

      const n = 5;
      let sumW = 0;
      for (let i = 0; i < n; i++) sumW += weights[i] ?? (1 / n);
      let acc = 0;

      for (let i = 0; i < n; i++) {
        const w = (weights[i] ?? (1 / n)) / Math.max(1e-6, sumW);
        const x0 = Math.floor(acc * c.width);
        acc += w;
        const x1 = Math.floor(acc * c.width);
        ctx.fillStyle = stops[i];
        ctx.fillRect(x0, 0, Math.max(1, x1 - x0), 1);
      }

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.NearestFilter;
      tex.magFilter = THREE.NearestFilter;
      tex.generateMipmaps = false;
      tex.needsUpdate = true;
      return tex;
    }

    /* Terrain */
    const TOON_RAMP_TUNDRA = makeToonRamp5([
      '#051E11', // deep conifer shadow
      '#0b3a22',
      '#155f38',
      '#4fa06a',
      '#cfeee0'  // sunlit grass highlight
    ]);

    /* Sea */
    const TOON_RAMP_SEA_RED = makeToonRampWeighted(
      ['#120506', '#2a0809', '#5a1213', '#b3231f', '#ff3a2a'],
      [0.10, 0.26, 0.28, 0.22, 0.14]
    );

    /* =========================
       RENDERER / SCENE
    ========================= */
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#3ad7ff');
    scene.fog = new THREE.Fog(0x2a0809, 8000, 30000);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 60000);

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* =========================
       POINTER LOCK + MOUSE LOOK
    ========================= */
    let CAN_LOCK = false;
    // called by the title-screen script when the world is fully loaded
    window.__mfEnablePointerLock = () => {
      CAN_LOCK = true;
    };

    function lockPointer() {
      if (!CAN_LOCK) return;
      if (!document.pointerLockElement) canvas.requestPointerLock();
    }
    canvas.addEventListener('click', lockPointer);

    document.addEventListener('pointerlockchange', () => {
      isLocked = (document.pointerLockElement === canvas);
    });

    document.addEventListener('mousemove', (e) => {
      if (!isLocked) return;
      yaw -= e.movementX * MOUSE_SENS;
      pitch -= e.movementY * MOUSE_SENS;
      pitch = THREE.MathUtils.clamp(pitch, PITCH_MIN, PITCH_MAX);
    });

    /* =========================
       LIGHTS
    ========================= */
    scene.add(new THREE.AmbientLight(0xffffff, 0.08));

    const sun  = new THREE.DirectionalLight(new THREE.Color(brightestHillColor), 3.1);
    sun.position.set(-2200, 700, 200);
    sun.target.position.set(0, 0, 0);
    scene.add(sun);
    scene.add(sun.target);

    const fill = new THREE.DirectionalLight(new THREE.Color(brightestHillColor), 0.24);
    fill.position.set(900, 1200, -600);
    scene.add(fill);

    /* Level root */
    const levelRoot = new THREE.Group();
    scene.add(levelRoot);

    /* =========================
       SKY DOME
    ========================= */
    function makeSkyDome() {
      const skyCanvas = document.createElement('canvas');
      skyCanvas.width = 32;
      skyCanvas.height = 256;
      const ctx = skyCanvas.getContext('2d');

      const grad = ctx.createLinearGradient(0, 0, 0, 256);
      grad.addColorStop(0.00, '#0b2a3a');
      grad.addColorStop(0.40, '#1f6fa1');
      grad.addColorStop(0.70, '#3ad7ff');
      grad.addColorStop(0.90, '#7fe9ff');
      grad.addColorStop(1.00, '#ffffff');

      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 32, 256);

      const tex = new THREE.CanvasTexture(skyCanvas);
      tex.colorSpace = THREE.SRGBColorSpace;

      const geo = new THREE.SphereGeometry(SKY_RADIUS, 32, 16);
      const mat = new THREE.MeshBasicMaterial({
        map: tex,
        side: THREE.BackSide,
        depthWrite: false,
        fog: false
      });
      scene.add(new THREE.Mesh(geo, mat));
    }
    makeSkyDome();

    /* Sun disc must match the directional light position (same direction, scaled) */
    let horizonSunMesh = null;
    function makeHorizonSun() {
      const SUN_RADIUS = 1000;
      const SUN_DIST = 14000;

      const sunGeo = new THREE.SphereGeometry(SUN_RADIUS, 32, 16);
      const sunMat = new THREE.MeshBasicMaterial({ color: 0xffffff, fog: false });
      horizonSunMesh = new THREE.Mesh(sunGeo, sunMat);
      scene.add(horizonSunMesh);

      updateHorizonSunPosition(SUN_DIST);
    }
    function updateHorizonSunPosition(dist) {
      if (!horizonSunMesh) return;

      const dir = sun.position.clone().normalize();
      horizonSunMesh.position.copy(dir.multiplyScalar(dist));
    }
    makeHorizonSun();

    /* =========================
       INPUT
    ========================= */
    const keys = new Set();
    addEventListener('keydown', e => {
      keys.add(e.code);

      if (e.code === 'Space') jumpBufferT = JUMP_BUFFER;
    });
    addEventListener('keyup', e => keys.delete(e.code));

    window.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    }, { capture: true });

    /* =========================
       HIDDEN DEV CONSOLE (Tab)
    ========================= */
    const devConsoleEl = document.getElementById('devConsole');
    const devConsoleInputEl = document.getElementById('devConsoleInput');

    let devConsoleOpen = false;
    let devBuffer = '';

    function openDevConsole() {
      devConsoleOpen = true;
      devBuffer = '';
      devConsoleInputEl.textContent = '';
      devConsoleEl.style.display = 'block';
    }
    function closeDevConsole() {
      devConsoleOpen = false;
      devBuffer = '';
      devConsoleInputEl.textContent = '';
      devConsoleEl.style.display = 'none';
    }

    function runDevCommand(cmdRaw) {
      const cmd = cmdRaw.trim().toLowerCase();

      if (cmd === 'superflea') {
        // Ensure avatar exists even if ./assets/ is missing
        ensureMezzaReady();
        VIEW_MODE = (VIEW_MODE === 'third') ? 'first' : 'third';
      }
    }

    /* Capture typing when console is open */
    addEventListener('keydown', (e) => {
      // Tab toggles console (hidden feature)
      if (e.code === 'Tab') {
        e.preventDefault();

        if (!devConsoleOpen) openDevConsole();
        else closeDevConsole();

        return;
      }

      if (!devConsoleOpen) return;

      // While open: prevent gameplay input from firing
      e.preventDefault();
      e.stopPropagation();

      if (e.code === 'Escape') {
        closeDevConsole();
        return;
      }

      if (e.code === 'Enter') {
        runDevCommand(devBuffer);
        closeDevConsole();
        return;
      }

      if (e.code === 'Backspace') {
        devBuffer = devBuffer.slice(0, -1);
        devConsoleInputEl.textContent = devBuffer;
        return;
      }

      // Accept printable characters
      if (e.key && e.key.length === 1) {
        // avoid weird control chars
        if (e.ctrlKey || e.metaKey) return;
        devBuffer += e.key;
        devConsoleInputEl.textContent = devBuffer;
      }
    }, { capture: true });

    addEventListener('keydown', (e) => {
      if (!deathActive) return;
      if (e.code === 'KeyR') {
        e.preventDefault();
        e.stopPropagation();
        if (deathLockoutT <= 0) respawn();
      }
    }, { capture: true });

    let jumpBufferT = 0;

    /* =========================
       LEVEL DATA
    ========================= */
    let mapW = 0, mapH = 0, cell = CELL_M, halfW = 0, halfH = 0;
    let heights = null;
    let waterMask = null;

    let MAX_LAND_HEIGHT = 0; // tallest interpreted green (computed at load)

    function idx(x, y) { return y * mapW + x; }
    function clamp(v, min, max) { return v < min ? min : (v > max ? max : v); }

    function isWaterPixel(x, y) {
      x = clamp(x, 0, mapW - 1);
      y = clamp(y, 0, mapH - 1);
      return waterMask && waterMask[idx(x, y)] === 1;
    }

    function isWaterAtWorld(wx, wz) {
      const gx = (wx + halfW) / cell;
      const gy = (wz + halfH) / cell;
      const ix = Math.floor(gx);
      const iy = Math.floor(gy);
      return (
        isWaterPixel(ix, iy) || isWaterPixel(ix + 1, iy) || isWaterPixel(ix, iy + 1) || isWaterPixel(ix + 1, iy + 1) ||
        isWaterPixel(ix - 1, iy) || isWaterPixel(ix, iy - 1) || isWaterPixel(ix + 2, iy) || isWaterPixel(ix, iy + 2)
      );
    }

    function heightAtGrid(ix, iy) {
      ix = clamp(ix, 0, mapW - 1);
      iy = clamp(iy, 0, mapH - 1);
      return heights[idx(ix, iy)];
    }

    function heightAtWorld(wx, wz) {
      if (isWaterAtWorld(wx, wz)) return SEA_LEVEL;

      const gx = (wx + halfW) / cell;
      const gy = (wz + halfH) / cell;
      const ix = Math.floor(gx), iy = Math.floor(gy);
      const fx = THREE.MathUtils.clamp(gx - ix, 0, 1);
      const fy = THREE.MathUtils.clamp(gy - iy, 0, 1);
      const h00 = heightAtGrid(ix, iy), h10 = heightAtGrid(ix + 1, iy), h01 = heightAtGrid(ix, iy + 1), h11 = heightAtGrid(ix + 1, iy + 1);
      return h00 * (1 - fx) * (1 - fy) + h10 * fx * (1 - fy) + h01 * (1 - fx) * fy + h11 * fx * fy;
    }

    function heightForRender(wx, wz) {
      if (isWaterAtWorld(wx, wz)) return FLOOR_Y;
      return heightAtWorld(wx, wz);
    }

    /* =========================
       HEIGHT DERIVATION
    ========================= */
    
// --- GIS-style contour ramp (distance-inspired, minimal & safe) ---
// Converts flat green bands into continuous ramps without changing map art.
function rampGreenBetweenBands(data, W, H, passes=12){
  const size = W*H;
  const g = new Float32Array(size);
  for(let i=0;i<size;i++) g[i] = data[i*4+1];

  const out = new Float32Array(size);
  out.set(g);

  const idx = (x,y)=>y*W+x;

  for(let p=0;p<passes;p++){
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        const i = idx(x,y);
        const v = out[i];
        let min = v, max = v;
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            const j = idx(x+dx,y+dy);
            const nv = out[j];
            if(nv < min) min = nv;
            if(nv > max) max = nv;
          }
        }
        // pull interior pixels toward neighbors if straddling a band edge
        if(min !== max){
          out[i] = (v + min + max * 7) / 9;
        }
      }
    }
  }

  for(let i=0;i<size;i++){
    data[i*4+1] = Math.max(0, Math.min(255, out[i]));
  }
}

function deriveHeightsAndWater(data) {
      
  // GIS-style ramping between green contour bands
  rampGreenBetweenBands(data, mapW, mapH, 16);
const h = new Float32Array(mapW * mapH);
      const wmask = new Uint8Array(mapW * mapH);
      const topMask = new Uint8Array(mapW * mapH);

      let minLandG = 255;
      for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
          const p = (y * mapW + x) * 4;
          const r = data[p], g = data[p + 1], b = data[p + 2], a = data[p + 3];
          if (a < 16) continue;
          if (isBorder(r, g, b)) continue;
          if (isSpecial(r, g, b)) continue;
          if (isGreenish(r, g, b)) minLandG = Math.min(minLandG, g);
        }
      }
      if (minLandG === 255) minLandG = 0;

      for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
          const p = (y * mapW + x) * 4;
          const r = data[p], g = data[p + 1], b = data[p + 2], a = data[p + 3];
          const i = idx(x, y);

          if (a < 16) {
            h[i] = 0;
            wmask[i] = 0;
            continue;
          }

          if (isBorder(r, g, b)) {
            h[i] = 0;
            wmask[i] = 1;
            continue;
          }

          if (isSpecial(r, g, b)) {
            h[i] = NaN;
            wmask[i] = 0;
            continue;
          }

          if (isGreenish(r, g, b)) {
            const gn = (g - minLandG) / Math.max(1, (255 - minLandG));
            const t = Math.pow(THREE.MathUtils.clamp(gn, 0, 1), HEIGHT_CURVE_POW);
            h[i] = t * BASE_MAX_HEIGHT;

            if (gn >= TOP_FLAT_GN_THRESHOLD) topMask[i] = 1;
          } else {
            h[i] = NaN;
          }
        }
      }

      const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]];
      for (let pass = 0; pass < mapW + mapH; pass++) {
        let changed = false;
        for (let y = 0; y < mapH; y++) {
          for (let x = 0; x < mapW; x++) {
            const i = idx(x, y);
            if (!Number.isNaN(h[i])) continue;

            let sum = 0, cnt = 0;
            for (const [dx, dy] of dirs) {
              const nx = x + dx, ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= mapW || ny >= mapH) continue;
              const ni = idx(nx, ny);
              if (wmask[ni]) continue;
              const v = h[ni];
              if (!Number.isNaN(v)) { sum += v; cnt++; }
            }
            if (cnt > 0) { h[i] = sum / cnt; changed = true; }
          }
        }
        if (!changed) break;
      }
      for (let i = 0; i < h.length; i++) if (Number.isNaN(h[i])) h[i] = 0;

      let sm = smoothHeightsLandOnly(h, wmask, SMOOTH_PASSES);

      let topH = -Infinity;
      for (let i = 0; i < sm.length; i++) {
        if (wmask[i]) continue;
        if (topMask[i]) topH = Math.max(topH, sm[i]);
      }
      if (topH > -Infinity) {
        for (let i = 0; i < sm.length; i++) {
          if (wmask[i]) continue;
          if (topMask[i]) sm[i] = topH;
        }
      }

      sm = smoothHeightsLandOnlyLocked(sm, wmask, topMask, SLOPE_PASSES);

      let maxH = 0;
      for (let i = 0; i < sm.length; i++) {
        if (wmask[i]) continue;
        maxH = Math.max(maxH, sm[i]);
      }
      MAX_LAND_HEIGHT = maxH;

      return { heights: sm, waterMask: wmask };
    }

    function smoothHeightsLandOnly(src, wmask, passes = 2) {
      let a = src, b = new Float32Array(src.length);
      for (let p = 0; p < passes; p++) {
        for (let y = 0; y < mapH; y++) {
          for (let x = 0; x < mapW; x++) {
            const i = idx(x, y);
            if (wmask[i]) { b[i] = a[i]; continue; }

            let sum = 0, cnt = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                const nx = x + dx, ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= mapW || ny >= mapH) continue;
                const ni = idx(nx, ny);
                if (wmask[ni]) continue;
                sum += a[ni];
                cnt++;
              }
            }
            b[i] = (cnt > 0) ? (sum / cnt) : a[i];
          }
        }
        const t = a; a = b; b = t;
      }
      return a;
    }

    function smoothHeightsLandOnlyLocked(src, wmask, lockMask, passes = 16) {
      let a = src, b = new Float32Array(src.length);

      for (let p = 0; p < passes; p++) {
        for (let y = 0; y < mapH; y++) {
          for (let x = 0; x < mapW; x++) {
            const i = idx(x, y);

            if (wmask[i]) { b[i] = a[i]; continue; }
            if (lockMask[i]) { b[i] = a[i]; continue; }

            let sum = 0, cnt = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                const nx = x + dx, ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= mapW || ny >= mapH) continue;
                const ni = idx(nx, ny);
                if (wmask[ni]) continue;
                sum += a[ni];
                cnt++;
              }
            }

            const avg = (cnt > 0) ? (sum / cnt) : a[i];
            b[i] = a[i] * 0.35 + avg * 0.65;
          }
        }
        const t = a; a = b; b = t;
      }

      return a;
    }

    /* =========================
       TERRAIN
    ========================= */
    let terrainMesh = null;

    function disposeMesh(m) {
      if (!m) return;
      m.geometry.dispose();
      m.material.dispose();
      levelRoot.remove(m);
    }

    function buildTerrainMesh() {
      disposeMesh(terrainMesh); terrainMesh = null;

      const sizeX = mapW * cell;
      const sizeZ = mapH * cell;
      halfW = sizeX / 2;
      halfH = sizeZ / 2;

      const segX = Math.max(1, Math.floor((mapW - 1) / SAMPLE_STEP));
      const segZ = Math.max(1, Math.floor((mapH - 1) / SAMPLE_STEP));

      const geo = new THREE.PlaneGeometry(sizeX, sizeZ, segX, segZ);
      geo.rotateX(-Math.PI / 2);

      const pos = geo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const wx = pos.getX(i);
        const wz = pos.getZ(i);
        pos.setY(i, heightForRender(wx, wz));
      }

      geo.computeVertexNormals();

      const mat = new THREE.MeshToonMaterial({
        color: 0xffffff,
        gradientMap: TOON_RAMP_TUNDRA,
        fog: true
      });

      terrainMesh = new THREE.Mesh(geo, mat);
      terrainMesh.renderOrder = 1;
      levelRoot.add(terrainMesh);
    }

    /* =========================
       WORLD WATER PLANE
    ========================= */
    let worldSeaPlane = null;

    function buildWorldSeaPlane() {
      if (worldSeaPlane) {
        levelRoot.remove(worldSeaPlane);
        worldSeaPlane.geometry.dispose();
        worldSeaPlane.material.dispose();
        worldSeaPlane = null;
      }

      const geo = new THREE.PlaneGeometry(WATER_PLANE_SIZE, WATER_PLANE_SIZE, 1, 1);
      geo.rotateX(-Math.PI / 2);

      const mat = new THREE.MeshToonMaterial({
        color: 0xffffff,
        gradientMap: TOON_RAMP_SEA_RED,
        emissive: 0x2a0000,
        emissiveIntensity: 0.55,
        fog: true,
        transparent: false,
        depthWrite: true,
        depthTest: true
      });

      worldSeaPlane = new THREE.Mesh(geo, mat);
      worldSeaPlane.position.set(0, WATER_PLANE_Y, 0);
      worldSeaPlane.renderOrder = 2;
      levelRoot.add(worldSeaPlane);
    }

    /* =========================
       COLLIDERS + SPATIAL HASH
    ========================= */
    const COLL_CELL = 28.0;
    const colliders = [];
    const grid = new Map();

    function key3(ix, iy, iz) { return `${ix},${iy},${iz}`; }

    function aabbForCapsule(a, b, r) {
      return {
        min: new THREE.Vector3(Math.min(a.x, b.x) - r, Math.min(a.y, b.y) - r, Math.min(a.z, b.z) - r),
        max: new THREE.Vector3(Math.max(a.x, b.x) + r, Math.max(a.y, b.y) + r, Math.max(a.z, b.z) + r)
      };
    }
    function gridInsert(id, min, max) {
      const x0 = Math.floor(min.x / COLL_CELL), x1 = Math.floor(max.x / COLL_CELL);
      const y0 = Math.floor(min.y / COLL_CELL), xY = Math.floor(max.y / COLL_CELL);
      const z0 = Math.floor(min.z / COLL_CELL), z1 = Math.floor(max.z / COLL_CELL);
      for (let x = x0; x <= x1; x++) {
        for (let y = y0; y <= xY; y++) {
          for (let z = z0; z <= z1; z++) {
            const k = key3(x, y, z);
            let arr = grid.get(k);
            if (!arr) { arr = []; grid.set(k, arr); }
            arr.push(id);
          }
        }
      }
    }
    function rebuildColliderGrid() {
      grid.clear();
      for (let i = 0; i < colliders.length; i++) {
        const c = colliders[i];
        if (c.type === 'cap') {
          const { min, max } = aabbForCapsule(c.a, c.b, c.r);
          gridInsert(i, min, max);
        } else {
          gridInsert(i, c.min, c.max);
        }
      }
    }
    function queryNearby(min, max) {
      const out = new Set();
      const x0 = Math.floor(min.x / COLL_CELL), x1 = Math.floor(max.x / COLL_CELL);
      const y0 = Math.floor(min.y / COLL_CELL), y1 = Math.floor(max.y / COLL_CELL);
      const z0 = Math.floor(min.z / COLL_CELL), z1 = Math.floor(max.z / COLL_CELL);
      for (let x = x0; x <= x1; x++) {
        for (let y = y0; y <= y1; y++) {
          for (let z = z0; z <= z1; z++) {
            const arr = grid.get(key3(x, y, z));
            if (!arr) continue;
            for (const id of arr) out.add(id);
          }
        }
      }
      return out;
    }

    /* Player capsule */
    const _pa = new THREE.Vector3(), _pb = new THREE.Vector3();
    function getPlayerCapsule(pos) {
      const footY = pos.y - PLAYER_EYE_HEIGHT;
      _pa.set(pos.x, footY + PLAYER_RADIUS, pos.z);
      _pb.set(pos.x, footY + PLAYER_RADIUS + PLAYER_CAPSULE_H, pos.z);
      return { a: _pa, b: _pb, r: PLAYER_RADIUS };
    }

    /* Hot-loop scratch */
    const _tmp1 = new THREE.Vector3();
    const _tmp2 = new THREE.Vector3();
    const _tmp3 = new THREE.Vector3();
    const _cpA = new THREE.Vector3();
    const _cpB = new THREE.Vector3();
    const _nrm = new THREE.Vector3();

    function closestPtsSegSeg(a0, a1, b0, b1, outA, outB) {
      const d1 = _tmp1.subVectors(a1, a0);
      const d2 = _tmp2.subVectors(b1, b0);
      const r = _tmp3.subVectors(a0, b0);
      const a = d1.dot(d1);
      const e = d2.dot(d2);
      const f = d2.dot(r);

      let s, t;
      if (a <= 1e-8 && e <= 1e-8) { outA.copy(a0); outB.copy(b0); return; }
      if (a <= 1e-8) {
        s = 0; t = THREE.MathUtils.clamp(f / e, 0, 1);
      } else {
        const c = d1.dot(r);
        if (e <= 1e-8) {
          t = 0; s = THREE.MathUtils.clamp(-c / a, 0, 1);
        } else {
          const b = d1.dot(d2);
          const denom = a * e - b * b;
          s = (denom !== 0) ? THREE.MathUtils.clamp((b * f - c * e) / denom, 0, 1) : 0;
          t = (b * s + f) / e;
          if (t < 0) { t = 0; s = THREE.MathUtils.clamp(-c / a, 0, 1); }
          else if (t > 1) { t = 1; s = THREE.MathUtils.clamp((b - c) / a, 0, 1); }
        }
      }
      outA.copy(a0).addScaledVector(d1, s);
      outB.copy(b0).addScaledVector(d2, t);
    }

    let lastSupportTag = '';

    function resolveCollisions(pos) {
      lastSupportTag = '';   // ✅ reset each call
      const cap = getPlayerCapsule(pos);
      const { min, max } = aabbForCapsule(cap.a, cap.b, cap.r);
      const ids = queryNearby(min, max);

      let supported = false;

      for (const id of ids) {
        const c = colliders[id];

        if (c.type === 'cap') {
          closestPtsSegSeg(cap.a, cap.b, c.a, c.b, _cpA, _cpB);
          _nrm.subVectors(_cpA, _cpB);
          const d2 = _nrm.lengthSq();
          const rr = cap.r + c.r;
          if (d2 >= rr * rr || d2 < 1e-10) continue;

          const d = Math.sqrt(d2);
          _nrm.multiplyScalar(1.0 / d);
          const pen = rr - d;

          pos.addScaledVector(_nrm, pen);
          if (_nrm.y > 0.55) {
            supported = true;
            lastSupportTag = c.tag || '';
          }

        } else {
          const pts = [cap.a, _tmp1.copy(cap.a).lerp(cap.b, 0.5), cap.b];
          let bestPen = 0;
          _nrm.set(0, 0, 0);

          for (const p of pts) {
            const cx = THREE.MathUtils.clamp(p.x, c.min.x, c.max.x);
            const cy = THREE.MathUtils.clamp(p.y, c.min.y, c.max.y);
            const cz = THREE.MathUtils.clamp(p.z, c.min.z, c.max.z);
            _tmp2.set(cx, cy, cz);
            _tmp3.subVectors(p, _tmp2);
            const d2 = _tmp3.lengthSq();
            if (d2 >= cap.r * cap.r || d2 < 1e-10) continue;
            const d = Math.sqrt(d2);
            const pen = cap.r - d;
            if (pen > bestPen) {
              bestPen = pen;
              _nrm.copy(_tmp3).multiplyScalar(1.0 / d);
            }
          }

          if (bestPen > 0) {
            pos.addScaledVector(_nrm, bestPen);
            if (_nrm.y > 0.55) {
              supported = true;
              lastSupportTag = c.tag || '';
            }
          }
        }
      }

      return supported;
    }

    /* =========================
       TREES (BLOB-LITERAL)
    ========================= */
    let treeTrunks = null;
    let treeBranches = null;

    function clearTrees() {
      if (treeTrunks) {
        levelRoot.remove(treeTrunks);
        treeTrunks.geometry.dispose();
        treeTrunks.material.dispose();
        treeTrunks = null;
      }
      if (treeBranches) {
        levelRoot.remove(treeBranches);
        treeBranches.geometry.dispose();
        treeBranches.material.dispose();
        treeBranches = null;
      }
    }

    function collectTreeBlobsFromBitmap(data) {
      const visited = new Uint8Array(mapW * mapH);
      const blobs = [];

      function inb(x, y) { return x >= 0 && y >= 0 && x < mapW && y < mapH; }

      const qx = new Int32Array(mapW * mapH);
      const qy = new Int32Array(mapW * mapH);

      for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
          const i = idx(x, y);
          if (visited[i]) continue;

          const p = i * 4;
          const r = data[p], g = data[p + 1], b = data[p + 2], a = data[p + 3];
          if (!isTreePixel(r, g, b, a)) { visited[i] = 1; continue; }

          let head = 0, tail = 0;
          visited[i] = 1;
          qx[tail] = x; qy[tail] = y; tail++;

          let sumX = 0, sumY = 0, count = 0;
          let minX = x, maxX = x, minY = y, maxY = y;

          while (head < tail) {
            const cx = qx[head];
            const cy = qy[head];
            head++;

            sumX += cx; sumY += cy; count++;
            if (cx < minX) minX = cx; if (cx > maxX) maxX = cx;
            if (cy < minY) minY = cy; if (cy > maxY) maxY = cy;

            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = cx + dx, ny = cy + dy;
                if (!inb(nx, ny)) continue;
                const ni = idx(nx, ny);
                if (visited[ni]) continue;

                const pp = ni * 4;
                const rr = data[pp], gg = data[pp + 1], bb = data[pp + 2], aa = data[pp + 3];
                if (isTreePixel(rr, gg, bb, aa)) {
                  visited[ni] = 1;
                  qx[tail] = nx; qy[tail] = ny; tail++;
                } else {
                  visited[ni] = 1;
                }
              }
            }
          }

          if (count > 0) {
            const cx = sumX / count;
            const cy = sumY / count;

            const dxp = (maxX - minX + 1);
            const dyp = (maxY - minY + 1);
            const diamPx = Math.max(1, Math.hypot(dxp, dyp));

            blobs.push({ cx, cy, diamPx, count });
            if (blobs.length > 12000) return blobs;
          }
        }
      }

      return blobs;
    }

    function buildTreeInstancesFromBlobs(blobs) {
      clearTrees();
      if (!blobs.length) return;

      const trunkGeo = new THREE.CylinderGeometry(TREE_TRUNK_TOP_R_BASE, TREE_TRUNK_R_BASE, 1, 10);
      const branchGeo = new THREE.CylinderGeometry(BRANCH_R1_BASE, BRANCH_R0_BASE, 1, 8);

      const trunkMat = new THREE.MeshStandardMaterial({
        color: TREE_COLOR_TRUNK,
        roughness: 0.85,
        metalness: 0.0,
        emissive: 0x110000,
        emissiveIntensity: 0.25,
        flatShading: true
      });

      const branchMat = new THREE.MeshStandardMaterial({
        color: TREE_COLOR_BRANCH,
        roughness: 1.0,
        metalness: 0.0,
        emissive: 0x000000,
        emissiveIntensity: 0.0,
        flatShading: true
      });

      treeTrunks = new THREE.InstancedMesh(trunkGeo, trunkMat, blobs.length);
      treeTrunks.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      const branchCount = blobs.length * BRANCHES_PER_TREE;
      treeBranches = new THREE.InstancedMesh(branchGeo, branchMat, branchCount);
      treeBranches.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      const m = new THREE.Matrix4();
      const t = new THREE.Vector3();
      const s = new THREE.Vector3();
      const q = new THREE.Quaternion();

      let bIdx = 0;

      for (let i = 0; i < blobs.length; i++) {
        const blob = blobs[i];

        const wx = blob.cx * cell - halfW + cell * 0.5;
        const wz = blob.cy * cell - halfH + cell * 0.5;

        const worldDiam = Math.max(0.25, blob.diamPx * cell);

        const radiusScale = THREE.MathUtils.clamp(worldDiam / (2.0 * cell), 0.20, 30.0);
        const heightScale = THREE.MathUtils.clamp(radiusScale * 0.90, 0.20, 40.0);

        const hRand = THREE.MathUtils.lerp(0.85, 1.45, Math.random());
        const trunkH = TREE_TRUNK_H_BASE * heightScale * hRand;
        const trunkR = TREE_TRUNK_R_BASE * radiusScale;

        const base = heightAtWorld(wx, wz);

        t.set(wx, base + trunkH * 0.5, wz);
        s.set(trunkR / TREE_TRUNK_R_BASE, trunkH, trunkR / TREE_TRUNK_R_BASE);
        q.identity();
        m.compose(t, q, s);
        treeTrunks.setMatrixAt(i, m);

        colliders.push({
          type: 'cap',
          tag: 'trunk',
          a: new THREE.Vector3(wx, base + trunkR, wz),
          b: new THREE.Vector3(wx, base + trunkH - trunkR, wz),
          r: trunkR * 1.05
        });

        for (let k = 0; k < BRANCHES_PER_TREE; k++) {
          const yT = THREE.MathUtils.lerp(BRANCH_MIN_Y, BRANCH_MAX_Y, Math.random());
          const by = base + trunkH * yT;

          const len = THREE.MathUtils.lerp(BRANCH_MIN_L_BASE, BRANCH_MAX_L_BASE, Math.random()) * heightScale * (1.0 - 0.10 * k);
          const thickness = THREE.MathUtils.lerp(0.75, 1.15, Math.random()) * radiusScale * (1.0 - 0.08 * k);

          const yawR = Math.random() * Math.PI * 2;
          const pitchR = THREE.MathUtils.degToRad(20 + Math.random() * 55);

          q.setFromEuler(new THREE.Euler(pitchR, yawR, 0, 'YXZ'));

          const outR = (trunkR + (BRANCH_R0_BASE * thickness)) * (0.95 + 0.35 * Math.random());
          const ox = Math.sin(yawR) * outR;
          const oz = Math.cos(yawR) * outR;

          t.set(wx + ox, by, wz + oz);
          s.set(thickness, len, thickness);

          m.compose(t, q, s);
          treeBranches.setMatrixAt(bIdx++, m);

          const A = new THREE.Vector3(0, -0.5, 0).applyMatrix4(m);
          const B = new THREE.Vector3(0, 0.5, 0).applyMatrix4(m);
          const br = (Math.max(BRANCH_R0_BASE, BRANCH_R1_BASE) * thickness) * 1.05;
          colliders.push({ type: 'cap', tag: 'branch', a: A, b: B, r: br });
        }
      }

      treeTrunks.instanceMatrix.needsUpdate = true;
      treeBranches.instanceMatrix.needsUpdate = true;

      levelRoot.add(treeTrunks);
      levelRoot.add(treeBranches);
    }

    /* =========================
       BUILDINGS (PERIMETER EXTRUDE)
    ========================= */
    let buildingWalls = null;

    const BUILD_WALL_HEIGHT = 100.0;
    const BUILD_WALL_SIMPLIFY_EPS_WORLD = 0.8;
    const BUILD_WALL_COLOR = 0x141414;

    function clearBuildings() {
      if (buildingWalls) {
        levelRoot.remove(buildingWalls);
        buildingWalls.traverse(obj => {
          if (obj.isMesh) {
            obj.geometry.dispose();
            obj.material.dispose();
          }
        });
        buildingWalls = null;
      }
    }

    function buildBuildingPerimeterFromBitmap(data) {
      clearBuildings();

      const mask = new Uint8Array(mapW * mapH);
      for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
          const i = idx(x, y);
          const p = i * 4;
          if (isHousePixel(data[p], data[p + 1], data[p + 2], data[p + 3])) mask[i] = 1;
        }
      }

      const edges = new Map();
      function addEdge(x0, y0, x1, y1) {
        const k = `${x0},${y0}`;
        let arr = edges.get(k);
        if (!arr) { arr = []; edges.set(k, arr); }
        arr.push([x1, y1]);
      }
      function inside(x, y) {
        if (x < 0 || y < 0 || x >= mapW || y >= mapH) return 0;
        return mask[idx(x, y)];
      }

      for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
          if (!inside(x, y)) continue;

          if (!inside(x, y - 1)) addEdge(x, y, x + 1, y);
          if (!inside(x + 1, y)) addEdge(x + 1, y, x + 1, y + 1);
          if (!inside(x, y + 1)) addEdge(x + 1, y + 1, x, y + 1);
          if (!inside(x - 1, y)) addEdge(x, y + 1, x, y);
        }
      }

      const used = new Set();
      function eKey(x0, y0, x1, y1) { return `${x0},${y0}->${x1},${y1}`; }

      const loops = [];

      for (const [startK, outs] of edges) {
        const [sx, sy] = startK.split(',').map(Number);
        for (const [nx, ny] of outs) {
          const ek = eKey(sx, sy, nx, ny);
          if (used.has(ek)) continue;

          const loop = [[sx, sy]];
          used.add(ek);

          let cx = nx, cy = ny;
          loop.push([cx, cy]);

          let guard = 0;
          while (guard++ < 200000) {
            if (cx === sx && cy === sy) break;

            const outArr = edges.get(`${cx},${cy}`);
            if (!outArr || outArr.length === 0) break;

            let found = null;
            for (const [ux, uy] of outArr) {
              const kk = eKey(cx, cy, ux, uy);
              if (!used.has(kk)) {
                found = [ux, uy, kk];
                break;
              }
            }
            if (!found) break;

            const [ux, uy, kk] = found;
            used.add(kk);
            cx = ux; cy = uy;
            loop.push([cx, cy]);
          }

          if (loop.length >= 4 && loop[0][0] === loop[loop.length - 1][0] && loop[0][1] === loop[loop.length - 1][1]) {
            loops.push(loop);
          }
        }
      }

      if (!loops.length) return;

      buildingWalls = new THREE.Group();
      levelRoot.add(buildingWalls);

      const mat = new THREE.MeshStandardMaterial({
        color: BUILD_WALL_COLOR,
        roughness: 0.8,
        metalness: 0.0,
        emissive: 0x080808,
        emissiveIntensity: 0.35
      });

      for (const loop of loops) {
        const pts = [];
        for (let i = 0; i < loop.length; i++) {
          const gx = loop[i][0];
          const gy = loop[i][1];

          const wx = gx * cell - halfW;
          const wz = gy * cell - halfH;

          pts.push(new THREE.Vector2(wx, -wz));
        }

        const simp = simplifyRDP2D(pts, BUILD_WALL_SIMPLIFY_EPS_WORLD);
        if (simp.length < 4) continue;

        const shape = new THREE.Shape(simp);

        const extrude = new THREE.ExtrudeGeometry(shape, {
          depth: BUILD_WALL_HEIGHT,
          bevelEnabled: false,
          steps: 1
        });

        extrude.rotateX(-Math.PI / 2);

        let cx = 0, cz = 0;
        for (const v of simp) {
          cx += v.x;
          cz += -v.y;
        }
        cx /= simp.length;
        cz /= simp.length;

        const baseY = Math.max(SEA_LEVEL, heightAtWorld(cx, cz));
        extrude.translate(0, baseY, 0);

        const mesh = new THREE.Mesh(extrude, mat);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        mesh.renderOrder = 3;

        buildingWalls.add(mesh);

        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        for (const v of simp) {
          const x = v.x;
          const z = -v.y;
          minX = Math.min(minX, x); maxX = Math.max(maxX, x);
          minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
        }
        colliders.push({
          type: 'box',
          min: new THREE.Vector3(minX, baseY, minZ),
          max: new THREE.Vector3(maxX, baseY + BUILD_WALL_HEIGHT, maxZ)
        });
      }
    }

    function simplifyRDP2D(points, eps) {
      if (points.length <= 4) return points;

      let pts = points;
      const last = pts[pts.length - 1];
      const first = pts[0];
      if (last.x === first.x && last.y === first.y) pts = pts.slice(0, -1);

      function distPointToSeg(p, a, b) {
        const vx = b.x - a.x, vy = b.y - a.y;
        const wx = p.x - a.x, wy = p.y - a.y;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
        const t = c1 / c2;
        const px = a.x + t * vx, py = a.y + t * vy;
        return Math.hypot(p.x - px, p.y - py);
      }

      function rdp(arr) {
        if (arr.length <= 2) return arr;
        const a = arr[0], b = arr[arr.length - 1];
        let maxD = -1, idxMax = -1;
        for (let i = 1; i < arr.length - 1; i++) {
          const d = distPointToSeg(arr[i], a, b);
          if (d > maxD) { maxD = d; idxMax = i; }
        }
        if (maxD > eps) {
          const left = rdp(arr.slice(0, idxMax + 1));
          const right = rdp(arr.slice(idxMax));
          return left.slice(0, -1).concat(right);
        }
        return [a, b];
      }

      let farI = 0, farD = -1;
      for (let i = 0; i < pts.length; i++) {
        const d = Math.hypot(pts[i].x - pts[0].x, pts[i].y - pts[0].y);
        if (d > farD) { farD = d; farI = i; }
      }
      const rotated = pts.slice(farI).concat(pts.slice(0, farI));
      const open = rotated.concat([rotated[0]]);

      const simp = rdp(open);

      if (simp.length && (simp[0].x !== simp[simp.length - 1].x || simp[0].y !== simp[simp.length - 1].y)) {
        simp.push(new THREE.Vector2(simp[0].x, simp[0].y));
      }
      return simp;
    }

    /* =========================
       BRIDGE (LONG PRISM FROM #c0c0c0)
    ========================= */
    let bridgeMesh = null;

    // East escape trigger tuning
    const EAST_WALL_EPS = 0.15;     // how close to the bound counts as "touch"
    const EAST_REQUIRE_BRIDGE = true; // set false if you want ANY east-wall touch to kill

    const BRIDGE_TOL = 10;
    function isBridgePixel(r, g, b, a) {
      if (a < 16) return false;
      return Math.abs(r - 192) <= BRIDGE_TOL &&
        Math.abs(g - 192) <= BRIDGE_TOL &&
        Math.abs(b - 192) <= BRIDGE_TOL;
    }

    function median(arr) {
      if (!arr.length) return 0;
      const a = arr.slice().sort((x, y) => x - y);
      const mid = (a.length / 2) | 0;
      return (a.length % 2) ? a[mid] : (a[mid - 1] + a[mid]) * 0.5;
    }

    function collectBridgeBandFromBitmap(data) {
      const cols = [];
      let minX = Infinity;
      let foundAny = false;

      for (let x = 0; x < mapW; x++) {
        let colMinY = Infinity;
        let colMaxY = -Infinity;
        let hit = false;

        for (let y = 0; y < mapH; y++) {
          const i = idx(x, y);
          const p = i * 4;
          if (isBridgePixel(data[p], data[p + 1], data[p + 2], data[p + 3])) {
            hit = true;
            foundAny = true;
            colMinY = Math.min(colMinY, y);
            colMaxY = Math.max(colMaxY, y);
          }
        }

        if (hit) {
          cols.push({ x, minY: colMinY, maxY: colMaxY });
          minX = Math.min(minX, x);
        }
      }

      if (!foundAny) return null;

      const thicknessPx = cols.map(c => (c.maxY - c.minY + 1));
      const centerYPx = cols.map(c => (c.minY + c.maxY) * 0.5);

      const widthPx = Math.max(1, Math.round(median(thicknessPx)));
      const centerY = median(centerYPx);

      return { startX: minX, widthPx, centerY };
    }

    function buildBridgePrism(band) {
      if (bridgeMesh) {
        levelRoot.remove(bridgeMesh);
        bridgeMesh.geometry.dispose();
        bridgeMesh.material.dispose();
        bridgeMesh = null;
      }
      if (!band) return;

      const BRIDGE_THICKNESS_Y = 2.0;
      const BRIDGE_COLOR = 0xc0c0c0;

      const bridgeWidthZ = Math.max(0.75, band.widthPx * cell);

      const xStart = band.startX * cell - halfW;
      const xEnd = SKY_RADIUS;
      const bridgeLengthX = xEnd - xStart;

      const zCenter = (band.centerY * cell - halfH) + cell * 0.5;

      const yBase = MAX_LAND_HEIGHT;

      const geo = new THREE.BoxGeometry(bridgeLengthX, BRIDGE_THICKNESS_Y, bridgeWidthZ);
      const mat = new THREE.MeshStandardMaterial({
        color: BRIDGE_COLOR,
        roughness: 0.7,
        metalness: 0.15,
        emissive: 0x050505,
        emissiveIntensity: 0.25
      });

      bridgeMesh = new THREE.Mesh(geo, mat);
      bridgeMesh.position.set(
        xStart + bridgeLengthX * 0.5,
        yBase + BRIDGE_THICKNESS_Y * 0.5,
        zCenter
      );
      bridgeMesh.renderOrder = 4;
      levelRoot.add(bridgeMesh);

      colliders.push({
        type: 'box',
        min: new THREE.Vector3(xStart, yBase, zCenter - bridgeWidthZ * 0.5),
        max: new THREE.Vector3(xEnd, yBase + BRIDGE_THICKNESS_Y, zCenter + bridgeWidthZ * 0.5)
      });
    }

    /* =========================
       ASSET-SAFE LOADING + FALLBACK AVATAR
    ========================= */
    function isUnderAssets(url) {
      return typeof url === 'string' && url.includes('/assets/');
    }

    async function safeLoad(label, url, loaderFn) {
      try {
        return await loaderFn(url);
      } catch (err) {
        if (isUnderAssets(url)) {
          console.warn(`[assets] failed to load ${label}: ${url}`, err);
          return null;
        }
        console.warn(`[load] failed to load ${label}: ${url}`, err);
        return null;
      }
    }

    // Player-ish sized black prism stand-in
    function makeFallbackMezzaPrism() {
      const bodyH = (PLAYER_CAPSULE_H + (PLAYER_RADIUS * 2.0));
      const bodyW = (PLAYER_RADIUS * 2.0) * 1.05;
      const bodyD = (PLAYER_RADIUS * 2.0) * 0.85;

      const geo = new THREE.BoxGeometry(bodyW, bodyH, bodyD);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0.95,
        metalness: 0.0,
        emissive: 0x050000,
        emissiveIntensity: 0.35
      });

      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      mesh.position.y = bodyH * 0.5;

      const g = new THREE.Group();
      g.add(mesh);
      return g;
    }

    let mezzaFallbackBuilt = false;
    function ensureMezzaReady() {
      if (mezzaWalk || mezzaRun || mezzaIdle || mezzaFallbackBuilt) return;

      mezzaIdle = makeFallbackMezzaPrism();
      mezzaWalk = makeFallbackMezzaPrism();
      mezzaRun = makeFallbackMezzaPrism();

      // Default state: idle
      mezzaIdle.visible = true;
      mezzaWalk.visible = false;
      mezzaRun.visible = false;

      mezzaRoot.add(mezzaIdle);
      mezzaRoot.add(mezzaWalk);
      mezzaRoot.add(mezzaRun);

      mezzaIdleMixer = null;
      mezzaWalkMixer = null;
      mezzaRunMixer = null;
      mezzaIdleAction = null;
      mezzaWalkAction = null;
      mezzaRunAction = null;

      mezzaFallbackBuilt = true;
    }

    /* =========================
       MEZZA (3rd PERSON CHARACTER)
    ========================= */
    const mezzaRoot = new THREE.Group();
    scene.add(mezzaRoot);

    let mezzaWalk = null;
    let mezzaRun = null;
    let mezzaIdle = null;
    let mezzaWalkMixer = null;
    let mezzaRunMixer = null;
    let mezzaIdleMixer = null;
    let mezzaWalkAction = null;
    let mezzaRunAction = null;
    let mezzaIdleAction = null;

    const loader = new GLTFLoader();

    async function loadMezza() {
      // Idle (when not moving)
      const gltfIdle = await safeLoad('Mezza idle GLB', MEZZA_IDLE_GLB, (u) => loader.loadAsync(u));
      if (gltfIdle && gltfIdle.scene) {
        mezzaIdle = gltfIdle.scene;
        mezzaIdle.traverse(o => { if (o.isMesh) { o.castShadow = false; o.receiveShadow = false; } });
        // Default state is idle
        mezzaIdle.visible = true;
        mezzaRoot.add(mezzaIdle);

        mezzaIdleMixer = new THREE.AnimationMixer(mezzaIdle);
        if (gltfIdle.animations && gltfIdle.animations.length) {
          mezzaIdleAction = mezzaIdleMixer.clipAction(gltfIdle.animations[0]);
          mezzaIdleAction.play();
        }
      } else {
        // If idle GLB fails, we'll fall back to walk-as-idle via setMezzaMode()
        mezzaIdle = null;
        mezzaIdleMixer = null;
        mezzaIdleAction = null;
      }

      // Walking
      const gltfWalk = await safeLoad('Mezza walk GLB', MEZZA_WALK_GLB, (u) => loader.loadAsync(u));
      if (gltfWalk && gltfWalk.scene) {
        mezzaWalk = gltfWalk.scene;
        mezzaWalk.traverse(o => { if (o.isMesh) { o.castShadow = false; o.receiveShadow = false; } });
        // Start hidden until we actually move (or until idle is missing)
        mezzaWalk.visible = !mezzaIdle;
        mezzaRoot.add(mezzaWalk);

        mezzaWalkMixer = new THREE.AnimationMixer(mezzaWalk);
        if (gltfWalk.animations && gltfWalk.animations.length) {
          mezzaWalkAction = mezzaWalkMixer.clipAction(gltfWalk.animations[0]);
          mezzaWalkAction.play();
        }
      } else {
        mezzaWalk = makeFallbackMezzaPrism();
        // If idle exists, keep walk hidden by default
        mezzaWalk.visible = !mezzaIdle;
        mezzaRoot.add(mezzaWalk);
        mezzaWalkMixer = null;
        mezzaWalkAction = null;
      }

      // Running
      const gltfRun = await safeLoad('Mezza run GLB', MEZZA_RUN_GLB, (u) => loader.loadAsync(u));
      if (gltfRun && gltfRun.scene) {
        mezzaRun = gltfRun.scene;
        mezzaRun.traverse(o => { if (o.isMesh) { o.castShadow = false; o.receiveShadow = false; } });
        mezzaRun.visible = false;
        mezzaRoot.add(mezzaRun);

        mezzaRunMixer = new THREE.AnimationMixer(mezzaRun);
        if (gltfRun.animations && gltfRun.animations.length) {
          mezzaRunAction = mezzaRunMixer.clipAction(gltfRun.animations[0]);
          mezzaRunAction.play();
        }
      } else {
        mezzaRun = makeFallbackMezzaPrism();
        mezzaRun.visible = false;
        mezzaRoot.add(mezzaRun);
        mezzaRunMixer = null;
        mezzaRunAction = null;
      }
    }

    function setMezzaMode(isRunning, moving) {
      ensureMezzaReady();
      if (!mezzaWalk || !mezzaRun) return;

      // If we don't have a dedicated idle model, use walk as idle for now.
      const hasIdle = !!mezzaIdle;

      if (!moving) {
        if (hasIdle) {
          mezzaIdle.visible = true;
          mezzaWalk.visible = false;
          mezzaRun.visible = false;
        } else {
          mezzaWalk.visible = true;
          mezzaRun.visible = false;
        }
        return;
      }

      // Moving
      if (hasIdle) mezzaIdle.visible = false;
      mezzaWalk.visible = !isRunning;
      mezzaRun.visible = isRunning;
    }

    function setMezzaVisible(vis) {
      mezzaRoot.visible = vis;
    }

    /* =========================
       PLAYER SPAWN
    ========================= */
    function findPlayerSpawn(data) {
      for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
          const p = (y * mapW + x) * 4;
          const r = data[p], g = data[p + 1], b = data[p + 2], a = data[p + 3];
          if (a < 16) continue;
          if (near([r, g, b], COLORS.PLAYER)) {
            return { x: x * cell - halfW + cell * 0.5, z: y * cell - halfH + cell * 0.5 };
          }
        }
      }
      return { x: 0, z: 0 };
    }

    /* =========================
       PLAYER STATE
    ========================= */
    const forwardV = new THREE.Vector3();
    const rightV = new THREE.Vector3();
    const wish = new THREE.Vector3();
    const vel = new THREE.Vector3();
    const playerPos = new THREE.Vector3(0, PLAYER_EYE_HEIGHT, 6);
    const spawnPos = new THREE.Vector3();

    /* =========================
       DEATH SYSTEM (DROWNING v1)
    ========================= */
    const DEATH_POEMS = {
      drown: `You plummet into the great red sea, you fail to float and twist in unnatural ways as you feel your lungs fill with a familiar iron-tasting viscous fluid.\n\nYou have died.`,
      exposure: `You attempt to flee by mantling up to the sky bridge, and walking across its infinite stretch to a seemingly more distant horizon; you fathom that marching onward for eternity is better than continued torment, but the cold starts to nip at your flesh, your fingers go numb, you shiver uncontrollably, and you eventually die from exposure.`,
      treefall: `Your clever attempts at breaking down trees to create a raft are thwarted as your feet give way and you tumble to the cold hard snow below.`
    };

    let deathActive = false;
    let deathCause = '';
    let deathSinkTargetEyeY = 0;
    let deathLockoutT = 0;

    const deathEl = document.getElementById('mfDeath');
    const deathPoemEl = document.getElementById('mfDeathPoem');

    function showDeathOverlay(text) {
      if (deathPoemEl) deathPoemEl.textContent = text || '';
      if (deathEl) {
        deathEl.style.display = 'grid';
        deathEl.setAttribute('aria-hidden', 'false');
      }
    }

    function hideDeathOverlay() {
      if (deathEl) {
        deathEl.style.display = 'none';
        deathEl.setAttribute('aria-hidden', 'true');
      }
    }

    function triggerDeath(cause) {
      if (deathActive) return;
      deathActive = true;
      deathCause = cause || 'drown';

      // sink the *eye* about half player height below the surface
      deathSinkTargetEyeY = SEA_LEVEL - (PLAYER_EYE_HEIGHT * 0.5);
      deathLockoutT = 0.10; // tiny delay so we don't instantly respawn by stray key

      // stop motion immediately
      vel.set(0, 0, 0);
      grounded = false;
      coyoteT = 0;
      jumpBufferT = 0;

      showDeathOverlay(DEATH_POEMS[deathCause] || 'You have died.');
    }

    async function respawn() {
      // ✅ reset state first
      deathActive = false;
      deathCause = '';
      deathLockoutT = 0;

      hideDeathOverlay();

      // ✅ hard reset movement state
      vel.set(0, 0, 0);
      grounded = false;
      supportedByCollider = false;
      coyoteT = 0;
      jumpBufferT = 0;

      // ✅ teleport to spawn
      playerPos.copy(spawnPos);

      // optional: clamp to ground in case terrain moved
      const groundY = Math.max(heightAtWorld(playerPos.x, playerPos.z), SEA_LEVEL) + PLAYER_EYE_HEIGHT;
      playerPos.y = groundY;

      // re-lock pointer (R is usually a user gesture)
      const c = document.getElementById('c');
      if (c && CAN_LOCK && !document.pointerLockElement) {
        try { c.requestPointerLock(); } catch { }
      }
    }

    function playerFootY() {
      return playerPos.y - PLAYER_EYE_HEIGHT;
    }

    function updateDeath(dt) {
      deathLockoutT = Math.max(0, deathLockoutT - dt); // ✅ tick down lockout

      const sinkSpeed = 1.65;
      playerPos.y = THREE.MathUtils.lerp(
        playerPos.y,
        deathSinkTargetEyeY,
        1.0 - Math.pow(0.000001, dt * sinkSpeed)
      );
    }

    let grounded = false;
    let coyoteT = 0;
    let supportedByCollider = false;

    /* =========================
       SLOPE SPEED helper (GROUND ONLY)
    ========================= */
    function slopeSpeedMultiplierAt(x, z, moveDirXZ) {
      if (!moveDirXZ || moveDirXZ.lengthSq() < 1e-8) return 1.0;

      const dx = moveDirXZ.x;
      const dz = moveDirXZ.z;

      const fX = x + dx * SLOPE_SAMPLE_DIST;
      const fZ = z + dz * SLOPE_SAMPLE_DIST;
      const bX = x - dx * SLOPE_SAMPLE_DIST;
      const bZ = z - dz * SLOPE_SAMPLE_DIST;

      const hF = heightAtWorld(fX, fZ);
      const hB = heightAtWorld(bX, bZ);

      const rise = (hF - hB);
      const run = (2.0 * SLOPE_SAMPLE_DIST);
      const slope = rise / Math.max(1e-5, run);

      if (slope > 0) {
        const penalty = 1.0 - (slope * SLOPE_STRENGTH_UP);
        return THREE.MathUtils.clamp(penalty, SLOPE_MAX_UP_PENALTY, 1.0);
      } else {
        const boost = 1.0 + (-slope * SLOPE_STRENGTH_DN);
        return THREE.MathUtils.clamp(boost, 1.0, SLOPE_MAX_DN_BOOST);
      }
    }

    /* =========================
       LOAD MAP / BUILD LEVEL
    ========================= */
    async function loadLevel() {
      levelRoot.clear();
      colliders.length = 0;

      const img = new Image();
      img.src = MAP_URL + '?v=' + Date.now();
      await img.decode();

      const bmp = await createImageBitmap(img);
      mapW = bmp.width;
      mapH = bmp.height;
      cell = CELL_M;

      const sizeX = mapW * cell;
      const sizeZ = mapH * cell;
      halfW = sizeX / 2;
      halfH = sizeZ / 2;

      SEA_LEVEL = WATER_PLANE_Y;

      const c = document.createElement('canvas');
      c.width = mapW;
      c.height = mapH;
      const ctx = c.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(bmp, 0, 0);
      const data = ctx.getImageData(0, 0, mapW, mapH).data;

      const derived = deriveHeightsAndWater(data);
      heights = derived.heights;
      waterMask = derived.waterMask;

      buildTerrainMesh();
      buildWorldSeaPlane();

      const blobs = collectTreeBlobsFromBitmap(data);
      buildTreeInstancesFromBlobs(blobs);

      buildBuildingPerimeterFromBitmap(data);

      const bridgeBand = collectBridgeBandFromBitmap(data);
      buildBridgePrism(bridgeBand);

      rebuildColliderGrid();

      const sp = findPlayerSpawn(data);
      const py = Math.max(heightAtWorld(sp.x, sp.z), SEA_LEVEL) + PLAYER_EYE_HEIGHT;
      playerPos.set(sp.x, py, sp.z);

      spawnPos.copy(playerPos); // ✅ remember spawn for respawn

      vel.set(0, 0, 0);
      grounded = false;
      coyoteT = 0;
      jumpBufferT = 0;
    }

    const CUTSCENE_IMAGES = [
      "images/blood_bay_1.png",
      "images/blood_bay_2.png",
      "images/blood_bay_3.png",
      "images/blood_bay_4.png",
      "images/blood_bay_5.png",
      "images/amadeus.png",
      "images/aristocrat.png",
    ];

    try {
      // Start prewarming ASAP (in parallel)
      const prewarmPromise = (async () => {
        // images (decode too)
        const p1 = window.__mfMemAssets?.prewarmImages(CUTSCENE_IMAGES, {
          concurrency: 2,
          onProgress: (done, total, url) => {
            const loaderEl = document.getElementById("loader");
            if (loaderEl) loaderEl.textContent = `loading… (${done}/${total})`;
          }
        });

        // audio (fetch only; decode later after user gesture)
        const p2 = window.__mfMemAssets?.prewarmFiles(WALK_STEP_SOUNDS, { concurrency: 2 });

        await Promise.all([p1, p2].filter(Boolean));
        return true;
      })();

      await loadLevel();
      await loadMezza();

      // IMPORTANT: don’t say “ready” until the cutscene assets are hot too
      if (prewarmPromise) await prewarmPromise;

    } catch (err) {
      console.error('[init] world init failed:', err);
    } finally {
      window.dispatchEvent(new Event('mf:world-ready'));
    }

    /* =========================
       MOVEMENT / PHYSICS STEP
    ========================= */
    function updatePlayer(dt) {
      if (deathActive) {
        updateDeath(dt);
        return;
      }

      const f = (keys.has('KeyW') ? 1 : 0) - (keys.has('KeyS') ? 1 : 0);
      const s = (keys.has('KeyD') ? 1 : 0) - (keys.has('KeyA') ? 1 : 0);
      const sprint = keys.has('ShiftLeft') || keys.has('ShiftRight');

      // Reuse a single UP vector (no per-frame allocations)
      const UP = (updatePlayer._UP ||= new THREE.Vector3(0, 1, 0));

      // -------------------------
      // Movement basis
      // -------------------------
      if (VIEW_MODE === 'third') {
        // Third-person: move relative to camera facing projected on XZ
        camera.getWorldDirection(forwardV);
        forwardV.y = 0;
        if (forwardV.lengthSq() < 1e-8) forwardV.set(0, 0, -1);
        forwardV.normalize();

        // ✅ right = forward × up  (fixes A/D)
        rightV.crossVectors(forwardV, UP).normalize();
      } else {
        // First-person: classic FPS forward (Three.js forward at yaw=0 is -Z)
        forwardV.set(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();

        // ✅ right = forward × up  (fixes A/D)
        rightV.crossVectors(forwardV, UP).normalize();
      }

      // Build wish direction
      wish.set(0, 0, 0);
      wish.addScaledVector(forwardV, f);
      wish.addScaledVector(rightV, s);
      if (wish.lengthSq() > 0) wish.normalize();

      // -------------------------
      // Jump + gravity
      // -------------------------
      jumpBufferT = Math.max(0, jumpBufferT - dt);
      coyoteT = grounded ? COYOTE_TIME : Math.max(0, coyoteT - dt);

      vel.y -= GRAVITY * dt;

      if (jumpBufferT > 0 && coyoteT > 0) {
        vel.y = JUMP_VEL;
        grounded = false;
        coyoteT = 0;
        jumpBufferT = 0;
      }

      // -------------------------
      // Horizontal motion
      // -------------------------
      if (grounded) {
        const baseSpd = sprint ? SPEED_SPRINT : SPEED_WALK;
        const slopeMul = slopeSpeedMultiplierAt(playerPos.x, playerPos.z, wish);
        const spd = baseSpd * slopeMul;
        vel.x = wish.x * spd;
        vel.z = wish.z * spd;
      } else {
        const maxSpd = sprint ? AIR_MAX_SPEED_SPRINT : AIR_MAX_SPEED_WALK;
        const targetX = wish.x * maxSpd;
        const targetZ = wish.z * maxSpd;

        const ax = (targetX - vel.x);
        const az = (targetZ - vel.z);
        const aLen = Math.hypot(ax, az);
        if (aLen > 1e-6) {
          const step = Math.min(aLen, AIR_ACCEL * dt);
          vel.x += (ax / aLen) * step;
          vel.z += (az / aLen) * step;
        }

        if (AIR_FRICTION > 0) {
          const fr = Math.max(0, 1.0 - AIR_FRICTION * dt);
          vel.x *= fr; vel.z *= fr;
        }
      }

      // -------------------------
      // Substep + collision
      // -------------------------
      const horizDist = Math.hypot(vel.x, vel.z) * dt;
      const vertDist = Math.abs(vel.y) * dt;
      const dist = horizDist + vertDist;
      const steps = Math.max(1, Math.ceil(dist / SUBSTEP_DIST));
      const subDt = dt / steps;

      supportedByCollider = false;
      const seaFloorY = SEA_LEVEL + PLAYER_EYE_HEIGHT;

      for (let i = 0; i < steps; i++) {
        playerPos.x += vel.x * subDt;
        playerPos.y += vel.y * subDt;
        playerPos.z += vel.z * subDt;

        playerPos.x = THREE.MathUtils.clamp(playerPos.x, -halfW + 1, halfW - 1);
        playerPos.z = THREE.MathUtils.clamp(playerPos.z, -halfH + 1, halfH - 1);

        const supported = resolveCollisions(playerPos);

        if (supported) supportedByCollider = true;

        const groundY = heightAtWorld(playerPos.x, playerPos.z) + PLAYER_EYE_HEIGHT;

        if (groundY > playerPos.y && (groundY - playerPos.y) <= MAX_STEP_UP) {
          playerPos.y = groundY;
          vel.y = Math.max(vel.y, 0);
          grounded = true;
        } else if (playerPos.y < groundY) {
          playerPos.y = groundY;
          vel.y = Math.max(vel.y, 0);
          grounded = true;
        } else {
          if (grounded && !supportedByCollider && playerPos.y > groundY) {
            const maxDown = DOWN_FOLLOW_SPEED * subDt;
            playerPos.y = Math.max(groundY, playerPos.y - maxDown);
            if (playerPos.y === groundY) {
              vel.y = Math.max(vel.y, 0);
              grounded = true;
            }
          }

          const gap = playerPos.y - groundY;
          if (!supportedByCollider && gap <= (0.08 * PLAYER_SCALE) && vel.y <= 0) {
            playerPos.y = groundY;
            vel.y = 0;
            grounded = true;
          } else if (!supportedByCollider && gap > (0.14 * PLAYER_SCALE)) {
            grounded = false;
          } else if (supportedByCollider) {
            grounded = true;
            if (vel.y < 0) vel.y = 0;
          }
        }

        if (!deathActive && playerPos.y < seaFloorY) {
          playerPos.y = seaFloorY;
          if (vel.y < 0) vel.y = 0;
          grounded = true;
        }
      }

      // POST-PHYSICS HAZARDS
      const footY = playerPos.y - PLAYER_EYE_HEIGHT;

      // must be over water AND actually touching it
      if (
        !deathActive &&
        isWaterAtWorld(playerPos.x, playerPos.z) &&
        footY <= SEA_LEVEL + 0.02
      ) {
        triggerDeath('drown');
        return;
      }

      // EAST WALL ESCAPE (exposure death)
      // Uses the same clamp bounds you already apply: clamp to [-halfW+1, halfW-1]
      if (!deathActive) {
        const eastBoundX = (halfW - 1); // matches your clamp line
        const touchingEast = playerPos.x >= (eastBoundX - EAST_WALL_EPS);

        // Optional: only kill if you're up at bridge height.
        // Your bridge is placed at yBase = MAX_LAND_HEIGHT and thickness is 2.0,
        // so being "on the bridge" basically means your feet are near MAX_LAND_HEIGHT.
        const onBridgeHeight = footY >= (MAX_LAND_HEIGHT - 1.0);

        if (touchingEast && (!EAST_REQUIRE_BRIDGE || onBridgeHeight)) {
          triggerDeath('exposure');
          return;
        }
      }

      // TREE BRANCH FAIL (trying to climb/break branches)
      if (
        !deathActive &&
        grounded &&
        supportedByCollider &&
        lastSupportTag === 'branch'
      ) {
        // Must be meaningfully above ground (prevents side-bumps / near-ground twigs)
        const groundFootY = heightAtWorld(playerPos.x, playerPos.z);
        const minClearance = 0.85 * PLAYER_SCALE; // tweak 0.6..1.2
        const elevated = (footY - groundFootY) > minClearance;

        if (elevated) {
          triggerDeath('treefall');
          return;
        }
      }

      // -------------------------
      // Footsteps (walking only)
      // -------------------------
      const horizSpeed = Math.hypot(vel.x, vel.z);

      const isWalkingNow =
        !deathActive &&
        grounded &&
        !sprint &&                 // ✅ NOT running
        horizSpeed > 0.6;          // ✅ actually moving (not just holding keys)

      if (isWalkingNow && footReady) {
        footTimer += dt;

        // optional: slight cadence scaling with speed (still simple)
        const cadence = FOOTSTEP_INTERVAL_S * THREE.MathUtils.clamp(10.0 / Math.max(1e-3, horizSpeed), 0.75, 1.25);

        if (footTimer >= cadence) {
          playFootstep();
          footTimer = 0;
        }
      } else {
        footTimer = 0;
      }

    }

    /* =========================
       CAMERA + MEZZA SYNC
    ========================= */
    const camPos = new THREE.Vector3();
    const camTarget = new THREE.Vector3();
    const desiredCam = new THREE.Vector3();
    const tmpRayDir = new THREE.Vector3();

    function updateMezzaAndCamera(dt) {
      // Always guarantee avatar exists (even if assets fail, or toggled later)
      ensureMezzaReady();

      applyCameraRotation();

      const sprint = keys.has('ShiftLeft') || keys.has('ShiftRight');
      const moving = (keys.has('KeyW') || keys.has('KeyA') || keys.has('KeyS') || keys.has('KeyD'));

      // Switch models: walking GLB for idle+walk, running GLB for sprint+move
      setMezzaMode(sprint && moving, moving);

      // Mezza follows the capsule feet so jump is visible (not locked to terrain height)
      const footY = playerPos.y - PLAYER_EYE_HEIGHT;
      mezzaRoot.position.set(playerPos.x, footY, playerPos.z);

      // Rotate Mezza to face movement direction when moving,
      // otherwise face camera yaw (so you can pose/aim).
      if (moving) {
        // direction from wish vector (already normalized)
        const ang = Math.atan2(wish.x, wish.z);
        mezzaRoot.rotation.set(0, ang, 0);
      } else {
        mezzaRoot.rotation.set(0, yaw, 0);
      }

      // Mezza visibility: hide in first-person so she doesn't block view
      setMezzaVisible(VIEW_MODE === 'third');

      // Update mixers (safe even when null)
      if (mezzaIdleMixer && mezzaIdle && mezzaIdle.visible) mezzaIdleMixer.update(dt);
      if (mezzaWalkMixer && mezzaWalk && mezzaWalk.visible) mezzaWalkMixer.update(dt);
      if (mezzaRunMixer && mezzaRun && mezzaRun.visible) mezzaRunMixer.update(dt);

      if (VIEW_MODE === 'first') {
        // First-person camera at player eye
        camera.position.set(playerPos.x, playerPos.y, playerPos.z);
        return;
      }

      // Third-person follow camera
      const back = THIRD_CAM_BACK;
      const up = THIRD_CAM_UP + (Math.sin(pitch) * 0.4 * PLAYER_SCALE);

      // desired camera position (behind player based on yaw)
      desiredCam.set(
        playerPos.x - Math.sin(yaw) * back,
        (heightAtWorld(playerPos.x, playerPos.z) + up),
        playerPos.z - Math.cos(yaw) * back
      );

      // Look-at target
      camTarget.set(playerPos.x, heightAtWorld(playerPos.x, playerPos.z) + THIRD_LOOK_UP, playerPos.z);

      // Optional simple anti-clipping: if desiredCam is "inside ground", lift it
      const camGround = heightAtWorld(desiredCam.x, desiredCam.z) + 0.65;
      if (desiredCam.y < camGround) desiredCam.y = camGround;

      // Smooth camera
      camera.position.lerp(desiredCam, 1.0 - Math.pow(0.000001, dt));
      camera.lookAt(camTarget);
    }

    /* =========================
       LOOP
    ========================= */
    const clock = new THREE.Clock();
    function animate() {
      const dt = Math.min(clock.getDelta(), 0.033);

      if (deathActive) {
        deathLockoutT = Math.max(0, deathLockoutT - dt);
        updateDeath(dt);
      } else {
        if (isLocked) {
          updatePlayer(dt);
        }
      }

      updateMezzaAndCamera(dt);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    window.__mfResetWorld = async () => {
      // If you want a “true reload”, you’re already doing the expensive rebuild here:
      await loadLevel();
      await loadMezza();

      // If your world has any other runtime state to reset, do it here
      vel.set(0, 0, 0);
      grounded = false;
      coyoteT = 0;
      jumpBufferT = 0;
    };

    // Optional: give the cutscene a way to clear held keys
    window.__mfClearKeys = () => {
      keys.clear();
    };
  </script>
  <!--<audio id="mfMusic" src="audio/megafuture_1.mp3" preload="auto" loop></audio>-->
</body>

</html>